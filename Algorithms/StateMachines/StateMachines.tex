\lab{Algorithms}{State Machines}{State Machines}
\objective{Explore deterministic and non deterministic finite automatons.}

A state machine is the simplest machine that can be considered a computer.
It is very similar to a Markov chain.
Both have a set of states and have a defined set of transitions between states.

\begin{definition}
A deterministic finite automaton (DFA) is described by a 5-tuple $(Q, \Sigma, \delta, q_0, A)$,
where
\begin{itemize}
\item $Q$ is a finite set of states
\item $\Sigma$ is a finite alphabet of recognized input symbols
\item $\delta$ is the machine's transition function
\item $q_0 \in Q$ is the machine's start state
\item $A \subseteq Q$ is the set of accept states
\end{itemize}
\end{definition}

A DFA describes a language or set of accepted inputs.  
If we give a DFA a particular input, it will tell us if that input exists in its language or not.
Let's look at a simple example in Figure \ref{fig:simple_dfa}.  We assume a two symbol alphabet, \{0, 1\}.  All the other elements of the DFA are shown graphically ($q_1$ is an accept state).
\begin{figure}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial](q0) {$q_0$};
\node[state,accepting] (q1) [right=of q0]{$q_1$};

\path[->] (q0) edge node {0} (q1);
\end{tikzpicture}
\caption{A simple deterministic finite automaton.}
\label{fig:simple_dfa}
\end{figure}
This only input accepted by this DFA is the string \texttt{0}.
That means, only the string \texttt{0} will cause the machine to transition to an accepting state, namely $q_1$.  Once we reach an accepting state, we stop, and the input consumed is an element of the language described by the DFA.
If there is still more input to be consumed, we fail.
You can think of every state having a transition to an implied failure state on unmatched input.
For example, if we gave the DFA the input \texttt{1} or \texttt{01} we would transition immediately to the failure state on the unmatched symbol.  A symbol is matched if there is a transition defined for it.
One possible way to represent the DFA in Figure \ref{fig:simple_dfa} is:
\begin{lstlisting}
def consume(in_str):
    for char in in_str:
        yield char
    
def state0(scanner):
    try:
        if scanner.next() == '0':
            return state1(scanner)
    except:
        pass
    return False
    
def state1(scanner):
    try:
        c = scanner.next()
    except StopIteration:
        return True
    return False
    
def dfa(in_str):
    scanner = consume(in_str)
    return state0(scanner)
\end{lstlisting}


\begin{problem}
Write a Python function that will simulate any given DFA.  
The above approach will not work!
Your function should accept as parameters an input string and a 4-tuple, \li{machine}, that describes the DFA as $(\Sigma, \delta, q_0, A)$ in the following format
\begin{enumerate}
\item A set with all symbols of the language's alphabet represented as strings.
\item A dictionary that defines the transition function.
It should map tuples of the form \li{(m, c)} to values, $n$, to represent the transition $q_m \xrightarrow{c} q_n$ ($m, n \in \mathbb{Z}$ and $c$ is a string).
\item An integer, $i$, representing $q_i$, the initial state.
\item A set of integers representing the accepting states.
\end{enumerate}
You function should return true if the given input string is an element of the language described by the DFA and false otherwise.
\label{prob:dfa_sim}
\end{problem}

\begin{problem}
Define the following DFAs using the format in Problem \ref{prob:dfa_sim} for describing a DFA.
\begin{figure}[H]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial,accepting] (q0) {$q_0$};
\node[state] (q1) [right=of q0] {$q_1$};

\path[->] 
(q0) edge[loop above] node {a} (q0)
(q1) edge[loop above] node {a} (q1)
(q0) edge[bend left] node {b} (q1)
(q1) edge[bend left] node {b} (q0);        
\end{tikzpicture}
\caption{\ref{prob:reprDFA}(a)}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial] (q0) {$q_0$};
\node[state] (q1) [right=of q0] {$q_1$};
\node[state,accepting] (q2) [right=of q1] {$q_2$};
\node[state] (q3) [right=of q2] {$q_3$};

\path[->]
(q0) edge[loop above] node {1} (q0)
(q0) edge node {0} (q1)
(q1) edge[loop above] node {1} (q1)
(q1) edge node {0} (q2)
(q2) edge[loop above] node {1} (q2)
(q2) edge node {0} (q3)
(q3) edge[loop above] node {0,1} (q3);
\end{tikzpicture}
\caption{\ref{prob:reprDFA}(b)}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial] (q0) {$q_0$};
\node[state,accepting] (q1) [right=of q0] {$q_1$};
\node[state,accepting] (q2) [above right=of q0] {$q_2$};
\node[state] (q3) [right=of q1] {$q_3$};
\node[state] (q4) [right=of q3] {$q_4$};

\path[->]
(q0) edge node {1} (q1)
(q0) edge node {0} (q2)
(q1) edge node {1} (q3)
(q1) edge node {0} (q2)
(q2) edge[loop above] node {0,1} (q2)
(q3) edge node {1} (q4)
(q3) edge node {0} (q2)
(q4) edge node {0,1} (q2);
\end{tikzpicture}
\end{figure}
\label{prob:reprDFA}
\end{problem}

\section*{Non-Deterministic Finite Automatons}
A non-deterministic finite automaton (NFA) are a generalization of deterministic state machines.
The difference between and NFA and a DFA is the transition function.
A transition for a DFA maps the current state and the input symbol to exactly one result state.
In contrast, an NFA can map the current state and the input symbol (or the empty string, $\epsilon$) to a set of resulting states.
If the set of resulting states has a cardinality greater than 1, the computation separates into independent branches.
For example, in Figure \ref{fig:simple_nfa}, given the input \texttt{0100}, we start at state $q_0$.  We match the first 0 and the active state is again $q_0$.  Next, we match a 1 and the resulting states are \{$q_0$, $q_1$, $q_2$\}.
At this point, our machine is in three states simultaneously (we transition to state $q_2$ on the $\epsilon$ transition).
This is the non-deterministic behavior of our state machine.
Our next input symbol is 0.
It is helpful to think of three separate and independent branches of computations.
\begin{enumerate}
\item State $q_0$ transitions back to $q_0$
\item State $q_1$ transitions to $q_2$
\item State $q_2$ transitions to $q_3$
\end{enumerate}
Our matching could terminate here, but since we have not completely read out input, we must still keep going.  The most we can say at this point is the string \texttt{010} is in the NFA's language.  Our current states are the set \{$q_0$, $q_2$, $q_3$\}.
Our last symbol is another 0.
\begin{enumerate}
\item State $q_0$ transitions back to itself
\item State $q_2$ transitions to $q_3$
\item State $q_3$ transitions to the implied fail state
\end{enumerate}
Now that we have read all of our input, and one of our final resulting states is an accepting state, we accept the entire string.  Does the string \texttt{01000} exist in the NFA's language?

You might think that this new power of NFAs will allow us to represent many more languages.  However, every language that can be represented as an NFA can also be represented by an equivalent DFA.  This is to say that an NFA is equivalent to a DFA in computing power.
In fact a method exists that will transform any NFA into an equivalent DFA.  This is, however, beyond the scope of this lab.
NFAs are quite useful though because they can often represent complex languages very simply and intuitively.
\begin{figure}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial] (q0) {$q_0$};
\node[state] (q1) [right=of q0] {$q_1$};
\node[state] (q2) [right=of q1] {$q_2$};
\node[state,accepting] (q3) [right=of q2] {$q_3$};

\path[->]
(q0) edge node {1} (q1)
(q0) edge[loop above] node {0,1} (q0)
(q1) edge node {0,1,$\epsilon$} (q2)
(q2) edge node {0,1} (q3);
\end{tikzpicture}
\caption{A simple non-deterministic finite automaton.}
\label{fig:simple_nfa}
\end{figure}

\begin{problem}
Draw a non-deterministic finite automaton that can match the following language.
\[L = \setconstruct{w \in L}{w\mbox{ where the number of a's is a multiple of 3, or contains least 4 b's, or where the number of c's is odd}}\]
\end{problem}


\section*{Operations on Regular Languages}
We can build machines that represent more complex languages by concatenating several simpler DFAs or NFAs together.  The format expression for concatenating the languages $A$ and $B$ is $A \circ B$.  We can also union the machines and thus union the languages they each represent (expressed as $A \cup B$).  
There are two more basic operations, \emph{star} and \emph{plus}, that are extremely useful.  Given a language, $L$, $L^*$ means that we can attach any number of strings in $L$ to get another string in $L^*$.  $L^+$ denotes one or more strings of $L$ have been attached to form a new string in $L^+$.  Note that $L^*$ and $L^+$ are different languages than $L$.

\section*{Introduction to Regular Expressions}
Regular expressions are not trivial or easy, but understanding them can be very straightforward.
The best way to think of regular expressions is the view them as operations on regular languages.  The entire regular expression represents a regular language.  In fact, the definition of being a regular language, $L$ means that there is a regular expression that represents $L$.   Since a every regular language can be represented by a DFA, we have an equivalence between regular expressions and DFAs.  And, because every NFA is equivalent to some DFA, we have a three-way equivalence (DFA=NFA=RE).  They are a \emph{very} compact way of representing complex state machines.
As noted, regular expressions can only represent a language if it is regular.  There do exist languages that are non-regular.  There are ways to rigorously prove that a language is non-regular, but that is beyond the scope of this lab.  A regular language is any language that can be represented as a regular expression, an NFA, or a DFA.

Regular expressions are especially useful and powerful for find and matching patterns in text.  Many tools can take advantage of the powerful matching features of regular expressions.  
\begin{warn}
Theoretically, regular expressions have a linear runtime.  However, because of more advanced features that many regular expression libraries have, poorly written regular expressions can have exponential runtime!  Profiling regular expressions is tricky because of their syntax.  A single character or two  could mean the difference between a fast regular expression and a regular expression that has practically infinite runtime (depending on the length of the input).
\end{warn}
