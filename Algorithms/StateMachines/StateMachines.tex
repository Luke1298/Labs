\lab{Algorithms}{State Machines}{State Machines}
\objective{Explore deterministic and non deterministic finite automatons.}

A state machine is the simplest machine that can be considered a computer.
It is very similar to a Markov chain.
Both have a set of states and have a defined set of transitions between states.

\begin{definition}
A deterministic finite automaton (DFA) is described by a 5-tuple $(Q, \Sigma, \delta, q_0, A)$,
where
\begin{itemize}
\item $Q$ is a finite set of states
\item $\Sigma$ is a finite alphabet of recognized input symbols
\item $\delta$ is the machine's transition function
\item $q_0 \in Q$ is the machine's start state
\item $A \subseteq Q$ is the set of accept states
\end{itemize}
\end{definition}

A DFA describes a language or set of accepted inputs.  
If we give a DFA a particular input, it will tell us if that input exists in its language or not.
Let's look at a simple example in Figure \ref{fig:simple_dfa}.  We assume a two symbol alphabet, \{0, 1\}.  All the other elements of the DFA are shown graphically ($q_1$ is an accept state).
\begin{figure}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial](q0) {$q_0$};
\node[state,accepting] (q1) [right=of q0]{$q_1$};

\path[->] (q0) edge node {0} (q1);
\end{tikzpicture}
\caption{A simple deterministic finite automaton.}
\label{fig:simple_dfa}
\end{figure}
This only input accepted by this DFA is the string \texttt{0}.
That means, only the string \texttt{0} will cause the machine to transition to an accepting state, namely $q_1$.  Once we reach an accepting state, we stop, and the input consumed is an element of the language described by the DFA.
If there is still more input to be consumed, we fail.
You can think of every state having a transition to an implied failure state on unmatched input.
For example, if we gave the DFA the input \texttt{1} or \texttt{01} we would transition immediately to the failure state on the unmatched symbol.  A symbol is matched if there is a transition defined for it.
One possible way to represent the DFA in Figure \ref{fig:simple_dfa} is:
\begin{lstlisting}
def consume(in_str):
    for char in in_str:
        yield char
    
def state0(scanner):
    try:
        if scanner.next() == '0':
            return state1(scanner)
    except:
        pass
    return False
    
def state1(scanner):
    try:
        c = scanner.next()
    except StopIteration:
        return True
    return False
    
def dfa(in_str):
    scanner = consume(in_str)
    return state0(scanner)
\end{lstlisting}


\begin{problem}
Write a Python function that will simulate any given DFA.  
The above approach will not work!
Your function should accept as parameters an input string and a 4-tuple, \li{machine}, that describes the DFA as $(\Sigma, \delta, q_0, A)$ in the following format
\begin{enumerate}
\item A set with all symbols of the language's alphabet represented as strings.
\item A dictionary that defines the transition function.
It should map tuples of the form \li{(m, c)} to values, $n$, to represent the transition $q_m \xrightarrow{c} q_n$ ($m, n \in \mathbb{Z}$ and $c$ is a string).
\item An integer, $i$, representing $q_i$, the initial state.
\item A set of integers representing the accepting states.
\end{enumerate}
You function should return true if the given input string is an element of the language described by the DFA and false otherwise.
\label{prob:dfa_sim}
\end{problem}

\begin{problem}
Define the following DFAs using the format in Problem \ref{prob:dfa_sim} for describing a DFA.
\begin{figure}[H]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial,accepting] (q0) {$q_0$};
\node[state] (q1) [right=of q0] {$q_1$};

\path[->] 
(q0) edge[loop above] node {a} (q0)
(q1) edge[loop above] node {a} (q1)
(q0) edge[bend left] node {b} (q1)
(q1) edge[bend left] node {b} (q0);        
\end{tikzpicture}
\caption{\ref{prob:reprDFA}(a)}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial] (q0) {$q_0$};
\node[state] (q1) [right=of q0] {$q_1$};
\node[state,accepting] (q2) [right=of q1] {$q_2$};
\node[state] (q3) [right=of q2] {$q_3$};

\path[->]
(q0) edge[loop above] node {1} (q0)
(q0) edge node {0} (q1)
(q1) edge[loop above] node {1} (q1)
(q1) edge node {0} (q2)
(q2) edge[loop above] node {1} (q2)
(q2) edge node {0} (q3)
(q3) edge[loop above] node {0,1} (q3);
\end{tikzpicture}
\caption{\ref{prob:reprDFA}(b)}
\end{figure}

\begin{figure}[H]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
\node[state,initial] (q0) {$q_0$};
\node[state,accepting] (q1) [right=of q0] {$q_1$};
\node[state,accepting] (q2) [above right=of q0] {$q_2$};
\node[state] (q3) [right=of q1] {$q_3$};
\node[state] (q4) [right=of q3] {$q_4$};

\path[->]
(q0) edge node {1} (q1)
(q0) edge node {0} (q2)
(q1) edge node {1} (q3)
(q1) edge node {0} (q2)
(q2) edge[loop above] node {0,1} (q2)
(q3) edge node {1} (q4)
(q3) edge node {0} (q2)
(q4) edge node {0,1} (q2);
\end{tikzpicture}
\end{figure}
\label{prob:reprDFA}
\end{problem}

\section*{Kleene Operators})


