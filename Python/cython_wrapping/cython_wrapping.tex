\newcommand{\of}{\texttt{.o}~}

\lab{Interfacing With Other Programming Languages Using Cython}{Interfacing With Other Programming Languages Using Cython}
\label{lab:cythonwrap}

\objective{Learn to interface with object files using Cython. This lab should be worked through on a machine that has already been configured to build Cython extensions using gcc or MinGW.}

Suppose you are writing a program in Python, but would like to call code written in another language.
Perhaps this code has already been debugged and heavily optimized, so you do not want to simply re-implement the algorithm in Python or Cython.
In technical terms, you want Python to \emph{interface} (or communicate) with the other language.
For example, NumPy's linear algebra functions call functions from LAPACK and BLAS, which are written in Fortran.

One way to have Python interface with C is to write a Cython \emph{wrapper} for the C function.
The wrapper is a Cython function that calls the C function. 
This is relatively easy to do because Cython compiles to C.
From Python, you can call the wrapper, which calls the C function (see Figure TODO).
%In this lab you will learn how to use Cython to wrap a C function.


% Describe .o files and dll's
% This is mainly just to help them know what is going on.
\section*{Wrapping with Cython: an overview}
When you use Cython to wrap a C function, you just write a Cython function that calls the C function.
To actually do this, we need to understand a little bit more about how C works.

After you write a program in C, you pass it to a compiler.
The compiler turns your C code into machine code, i.e., instructions that your computer can read.
The output of the compiler is an \emph{object file}.

In our scenario, we have C code defining a single function that we would like to wrap in Cython.
This C code has already been compiled to an object file.
The protocol for calling the C code from Cython is similar to calling it from C:
\begin{enumerate}
\item we need to \emph{include a header file} for the C code in our Cython code, and
\item we must \emph{link to the object file} compiled from the C code when we compile the Cython code.
\end{enumerate}

A \emph{header} for a file contains the declaration of the function defined in the file.
We include the header in the Cython code so that the compiler can check that the function is called with the right number and types of arguments.
Then, when we tell the compiler to \emph{link to} the object file, we simply tell it where to find the instructions defining the function declared in the header.

The Cython code will compile to a second object file.
This object file defines a module that can be imported into Python.

\section*{Wrapping with Cython: an example}
As an example, we will wrap the C function \texttt{ctridiag()} below.
This function computes the solution to a tridiagonal system $A\v = \x$.
Its parameters are pointers to four 1-D arrays, which satisfy the following:
\begin{itemize}
\item Arrays \li{a} and \li{c} have length \li{n-1} and contain the first subdiagonal and superdiagonal of $A$, respectively.
\item Arrays \li{b} and \li{x} have length \li{n} and represent the main diagonal of $A$ and $\x$, respectively.
\end{itemize}
The array \li{c} is used to store temporary values and \li{x} is transformed into the solution of the system.

\lstinputlisting[style=fromfile, language=C, name=ctridiag.c]{./ctridiag/ctridiag.c}

This terminal command tells the C-compiler gcc to compiles \texttt{ctridiag.c} to an object file \texttt{ctridiag.o}.

\begin{lstlisting}
>>> gcc -fPIC -c ctridiag.c -o ctridiag.o
\end{lstlisting}
The \texttt{-fPIC} option is required when building code for a shared object.
The \texttt{-c} flag prevents the compiler from raising an error even though \texttt{ctridiag.c} does not have a \li{main} function.
%TODO: What's this about shared objects? I thought the object wasn't shared yet . . . and the output has a .o extension . . .




\subsection*{Write a header for \texttt{ctridiag.c}}

The header file essentially contains a function declaration for \li{ctridiag()}.
It tells Cython how to use the object file \li{ctridiag.o}.
\lstinputlisting[style=fromfile, language=C, name=ctridiag.h]{./ctridiag/ctridiag.h}

\subsection*{Write a Cython wrapper}
Next we write a Cython file containing a function that ``wraps'' \li{ctridiag()}.
This file must include the header we wrote in the previous step.

\lstinputlisting[style=fromfile, language=Python, name=cython_ctridiag.pyx]{./ctridiag/cython_ctridiag.pyx}

Some comments on this code are in order. 
First, including the header for \li{ctridiag()} allows us to call this function even though it was not defined in this file.
This is a little like importing NumPy at the start of your Python script.

Second, the arguments of the Cython function \li{cytridiag()} are not in bijection with the arguments of \li{ctridiag()}.
In fact, Cython does not need to know the size of the NumPy arrays it accepts as inputs because these arrays are objects that carry that information with them.
We extract this information and pass it to the C function inside the Cython wrapper.

However, it is possible to unintentionally access memory outside of an array by calling this function.
For example, suppose the input arrays \li{a}, \li{b}, \li{c}, and \li{x} are of sizes 4, 5, 3, and 5.
Since \li{x} is used to determine the size of the system, the function \li{ctridiag()} will expect \li{c} to have length 4.
At some point, \li{ctridiag()} will likely try to read or even write to the 4th entry of \li{c}.
This address does exist in memory, but it does not contain an entry of \li{c}!
Therefore, this function must be called by a responsible user who knows the sizes of her arrays.
Alternatively, you could check the sizes of the arrays in the Cython wrapper before passing them to the C function.

Finally, the C function expects a parameter \li{double* a}, meaning that \li{a} is a \emph{pointer to} (i.e., the address of) a \li{double}.
The funtion \li{ctridiag()} expects this double to be the first entry of the array \li{a}.
So instead of passing the object \li{a} to \li{ctridiag()}, we find the first entry of \li{a} with \li{a[0]}, and then take its address with the \li{&} operator.





\subsection*{Compile the Cython wrapper}

Now we can compile \texttt{cython\_ctridiag.pyx} to build the Python extension.
The following setup file uses distutils to compile the Cython file, and may be run on Windows, Linux, or Macintosh-based computers.
Notice that in line 28, we link to the existing object file \texttt{ctridiag.o}.

\lstinputlisting[style=fromfile, language=Python, name=ctridiag_setup_distutils.py]{./ctridiag/ctridiag_setup_distutils.py}

This setup file can be called from the command line with the following command.
\begin{lstlisting}[style=ShellInput]
python ctridiag_setup_distutils.py build_ext --inplace
\end{lstlisting}
The \texttt{--inplace} flag tells the script to compile the extension in the current directory.
The appendix at the end of this lab contains setup files that build the Python extension by hand on various operating systems.





\subsection*{Test the Python extension}
After running the setup file, you should have a Python module called \li{cython_cytridiag} that defines a function \li{cytridiag()}.
You can import this module into IPython as usual.
However, if you modify \li{ctridiag()} and then try to recompile the extension, you may get an error if the module is currently in use.
Hence, if you are frequently recompiling your extension, it is wise to test it  with a script.

The following script tests the module \li{cython_cytridiag}.

\lstinputlisting[style=fromfile, language=Python, name=ctridiag_test.py]{./ctridiag/ctridiag_test.py}

%TODO: replace the C function for this problem with one that implements Monte Carlo integration

\section*{Another example}


The C function \li{cssor()} below implements the Successive Over Relaxation algorithm for solving Laplace's equation, which in two dimensions is
\[
\frac{\partial^2 F}{\partial x^2} + \frac{\partial^2 F}{\partial y^2} = 0.
\]
In the Successive Over Relaxation algorithm, an input array is iteratively modified until it converges to the solution $F(x,y)$.

\lstinputlisting[style=fromfile, language=C, name=cssor.c]{./cssor/cssor.c}

The function \li{cssor()} accepts the following inputs.
\begin{itemize}
\item $U$ is a pointer to an array of double precision numbers.
\item $m$ is an integer storing the number of rows of $U$.
\item $n$ is an integer storing the number of columns of $U$.
\item $\omega$ is a double precision floating point value between $1$ and $2$.
The closer this value is to $2$, the faster the algorithm will converge, but if it is too close the algorithm may not converge at all.
For this lab just use $1.9$.
\item tol is a floating point number storing a tolerance used to determine when the algorithm should terminate.
\item maxiters is an integer storing the maximum allowable number of iterations.
\item info is a pointer to an integer.
This function will set info to $0$ if the algorithm converged to a solution within the given tolerance.
It will set info to $1$ if it did not.
\end{itemize}



\begin{problem}
Wrap \li{cssor()} so it can be called from Python, following these steps.
\begin{enumerate}
\item Write a C header for \li{cssor.c}.
\item Write a Cython wrapper for the function \li{cssor()} as follows.
    \begin{enumerate}
    \item Have your Cython function accept parameters \li{tol} and \li{maxiters} that default to $10e^{-9}$ and 10,000, respectively.
    What other arguments does the Cython function need to accept?
    \item ordered arrays
    \item Make the Cython wrapper raise an error if \li{cssor()} fails to converge---i.e., if \li{cssor()} sets \li{info} to 1.
    %TODO How?
    \end{enumerate}
\item Write a test script for your Cython function.
    \begin{enumerate}
    \item how to test
    \item make a plot
    \end{enumerate}
\end{enumerate}
\end{problem}

\section*{Wrapping a Fortran Function(Optional)}
We can also use Cython to wrap Fortran.
As an example, we will wrap the Fortran function below, which implements the same algorithm as \li{ctridiag()}.

We have used the C library \li{iso_c_binding} to make the function accept pointers to native C types.
If we were wrapping a function or subroutine that we did not write ourselves we would have to define a Fortran function that uses the \li{iso_c_binding} library to accept pointers from C and then uses the values it receives to call the original function.
\lstinputlisting[style=fromfile, language=Fortran, name=ftridiag.f90]{./ftridiag/ftridiag.f90}

\begin{warn}
When interfacing between Fortran and C, you will have to pass pointers to \emph{all} the variables you send to the Fortran function as arguments.
Passing a variable directly will probably crash Python.
\end{warn}

\subsection*{Write a header for \texttt{ftridiag.f90}}
Here is a header that tells C how to interface with the function we have just defined.
\lstinputlisting[style=fromfile, language=C, name=ftridiag.h]{./ftridiag/ftridiag.h}

To compile \li{ftridiag.f90} to an object file you can run the following command in your command line:
\begin{lstlisting}[style=ShellInput]
gfortran -fPIC -c ftridiag.f90 -o ftridiag.o
\end{lstlisting}

\subsection*{Write a Cython wrapper and compile it}

Aside from the small changes in the names used, the modified header file, and the use of gfortran instead of gcc, the rest of the compilation process is entirely the same.
The test script that verifies that the function works properly is the same except that it will import the function from the module \li{cython_ftridiag} instead.
The setup files specific to Windows and Linux, the setup file using distutils, and the test script are included in this lab folder.

\begin{warn}
When working with higher dimensional arrays Fortran differs from C in that the columns are stored in contiguous blocks of memory instead of the rows.
The default for NumPy and for C arrays is to have rows stored in contiguous blocks, but this varies, depending on what computation has already been done with the NumPy array.
This means that, whenever you need to interface with Fortran code that is meant to act on arrays with multiple dimensions, you \emph{must} be very careful about what is a row and what is a column.
When you pass a Fortran subroutine a pointer to an array it will, by default, assume that the entries of the array are arranged in Fortran order.
Many Fortran routines have options that allow you to specify whether to act on an array or its transpose, but you should still be very careful about this.
\end{warn}

\begin{info}
It may seem unusual that we have already provided a Fortran function that has been modified so that it is callable from C.
Though this is not pure Fortran, it is not necessarily an uncommon scenario.
Many larger Fortran libraries (for example, LAPACK) provide C wrappers for all their functions.
When wrapping a Fortran library, a C wrapper may already be available for use.
\end{info}

Here is a file for the next problem:
\lstinputlisting[style=fromfile, language=Fortran, name=fssor.f90]{./fssor/fssor.f90}

\begin{problem}
The Fortran subroutine \li{fssor} included with this lab uses a technique called Successive Over Relaxation to solve Laplace's equation on a rectangular domain discretized as a grid of equally spaced points.
It solves the same problem as the one involving Laplace's equation in Lab \ref{lab:NumPyArrays}.
It takes the following inputs:
\begin{itemize}
\item $U$ is expected to be a pointer to a Fortran ordered array of double precision numbers.
\item $m$ is a pointer to an integer storing the number of rows of $U$.
\item $n$ is a pointer to an integer storing the number of columns of $U$.
\item $\omega$ is a pointer to a double precision floating point value storing some parameter between $1$ and $2$.
The closer this value is to $2$, the faster the algorithm will converge, but if it is too close the algorithm may not converge at all.
For this lab just use $1.9$.
\item tol is a pointer to a floating point number storing a tolerance used to determine when the algorithm should terminate.
\item maxiters is a pointer to an integer storing the maximum allowable number of iterations.
\item info is a pointer to an integer.
This subroutine will set info to $0$ if it converged to a solution within the given tolerance.
It will set info to $1$ if it did not.
\end{itemize}

Write a corresponding C header \li{fssor.h}, Cython wrapper \li{cython_fssor.pyx}, and Cython setup file (using distutils) \li{fssor_setup_distutils.py} to wrap this subroutine for use in Python.
Call the wrapper function in your Cython file \li{cyssor}.

Fortran works with Fortran ordered arrays, but this algorithm does not need any particular orientation of axes.
Have your Cython wrapper swap the length of the axes when calling \li{fssor} if the array is C ordered.
If it is Fortran ordered, pass the lengths as they are.
Have the wrapper raise an error if the array $U$ is neither Fortran ordered nor C ordered.
Also have it raise an error if the algorithm failed to converge to within the desired tolerances (i.e. if the function sets info to 1).
Use keyword arguments to pass \li{fssor} a default tolerance of $10e^{-9}$ and a default maximum number of iterations to 10000.

Here is how you should be able to call this function:
\begin{lstlisting}
import numpy as np
from cython_fssor import cyssor
resolution = 501
U = np.zeros((resolution, resolution))
X = np.linspace(0, 1, resolution)
U[0] = np.sin(2 * np.pi * X)
U[-1] = - U[0]
cyssor(U, 1.9)
\end{lstlisting}

Generate a 3D plot of $U$ after it has been modified by the function \li{cyssor}.
Use equally spaced points between 0 and 1 as your $x$ and $y$ values.
\end{problem}




\begin{warn}
When passing arrays as pointers to C, C++, and Fortran functions, be \emph{absolutely sure} that the array being passed is contiguous.
This means that the entries of the array are stored in \emph{adjacent} entries in memory.
Passing one of these functions a strided array will result in out of bounds memory accesses and could crash your computer.
When working with two dimensional arrays, C and C++ expect rows to be stored in contiguous blocks of memory.
Fortran expects columns to be stored in contiguous blocks of memory.

To avoid out of bounds memory accesses, be sure to pass in the size of the array as a separate parameter.
\end{warn}

\section*{Appendix: compiling C extensions for Python}
If you know more about compilers, you may find it enlightening to manually compile a C extension for Python.
Here we show how to manually compile \texttt{cython\_ctridiag.pyx} on Windows, Linux, and Macintosh machines.

On Windows, using the compiler MinGW (a version of gcc for windows), the compilation can be performed by running the following setup file.

\lstinputlisting[style=fromfile, language=Python, name=ctridiag_setup_windows64.py]{./ctridiag/ctridiag_setup_windows64.py}

The following file works on Linux and Macintosh machines using gcc.

\lstinputlisting[style=fromfile, language=Python, name=ctridiag_setup_linux.py]{./ctridiag/ctridiag_setup_linux.py}

