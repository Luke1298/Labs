\lab{Python}{The Standard Library}{Standard Library}
\objective{Become familiar with the Python standard library}

Python has a very rich set of tools available by default.
There are about 80 built-in functions that are always present in any Python environment.
In addition to these 80 core functions, the standard library includes thousands of useful routines and classes that cover almost every imaginable need.
Python has a ``batteries included'' philosophy in its standard library.
This philosophy makes complex tasks almost trivial to implement using the standard library.
There are many sophisticated and robust modules available in the standard library.

\section*{File Objects in Python}
One of the built-in functionalities of Python is working with files.
Python has a useful file object which acts as an interface to all kinds of different streams.
File objects are created using the built-in \li{open} command.
The \li{open} command accepts up to three arguments: filename, mode, and buffering.
The mode determines the kind of access to use when opening the file.
Possible mode strings are described in Table \ref{table:filemodes}.
If your file cannot be opened for any reason, an exception is raised.
\begin{table}
\begin{tabular}{|l|p{10cm}|}
\hline
Mode & Description \\
\hline
\li{r} & Opens a file for read-only access. This is the default mode. \\
\li{w} & Opens a file for write-only access.  This mode will create the file if it doesn't exist, or overwrite the file if it does exist. \\
\li{a} & Opens a file for appending.  The file pointer is at the end of the file.  Creates a new file if none exists. \\
\hline
\hline
Modifier & Description \\
\hline
\li{b} & Open a file in binary mode. \\
\li{+} & Open a file for read/write access.  Note that \li{r+} and \li{w+} are \emph{not} equivalent. \\
\hline
\end{tabular}
\caption{File open modes.}
\label{table:filemodes}
\end{table}

Every file object has several attributes and methods (Table \ref{table:fileattribs}).
\begin{table}
\begin{tabular}{|l|l|}
\hline
Attribute & Description \\
\hline
\li{closed} & True if file object is closed. \\
\li{mode} & The access mode used to open the file object. \\
\li{name} & The name of the file. \\
\hline
\hline
Method & Description \\
\hline
\li{close()} & Flush any buffered writes and close the file object. \\
\li{flush()} & Flush any buffered writes.  File object remains open. \\
\li{read()} & Read the next string of the file. \\
\li{readline()} & Read a line of the file. \\
\li{readlines()} & Read lines of the file until end of file. \\
\li{seek(offset)} & Place the file pointer at a certain position within the file. \\
\li{tell()} & Return the current position of the file pointer. \\
\li{write()} & Write a string to the file. \\
\li{writelines()} & Write a sequence of strings to the file. \\
\hline
\end{tabular}
\caption{File object attributes and methods.}
\label{table:fileattribs}
\end{table}

We can open a file as follows
\begin{lstlisting}
f = open('filename.txt','r')
#This will iterate through our entire file and print each line.
for line in f:
        print line
f.close()
\end{lstlisting}
However, it is preferred to open files in the following manner.
Notice that we don't have to explicitly close the file.
The moment we exit the \li{with} block, the file is automatically closed safely.
Using the method below is preferred because your files are guaranteed to be closed properly, even if an unexpected error happens.
\begin{lstlisting}
with open('filename.txt', 'r') as f:
    for line in f:
        print line
\end{lstlisting}

To write to a file, we would do something similar to the following.
\begin{lstlisting}
num = 17
with open('output.txt', 'w'):
    f.write("My favorite number: ")
    f.write(str(num))
\end{lstlisting}

Note that we can declare variables inside the \li{with} block that are accessible outside that block.
\begin{lstlisting}
#read our file using a with statement
with open('filename.txt', 'r') as f:
        read_data = f.read()
print read_data
\end{lstlisting}

One of the reasons Python is so useful as a scientific computing platform is because it is not limited to scientific computing alone.
Python has a very large and comprehensive standard library that is available with almost every Python environment.
The standard library is comprised of over a hundred different modules that provide extra functionality to Python.
Python modules are simply Python source files where classes, functions, variables are defined.
We can import any Python source file and access the objects defined in it.
In this lab, we will look at some of these modules.

Python modules can be imported with the \li{import} statement. 
Variables and methods defined by the module may then be called.
If we only need access to particular variables or methods, we can import them into the main namespace explicitly using \li{from module import item}.
For modules with longer names, we can bind it to a shorter alias using the \li{as} keyword.
\begin{lstlisting}
import math
import random as rand   #random is now aliased as rand
from collections import deque   #only import the deque from collections
math.sqrt(3)    #uses the square root method from the math module.\end{lstlisting}

\section*{\texttt{sys} Module}
The \li{sys} module allows us to access information specific to the system running Python.
For example, we often import \li{sys} to get the list \li{sys.argv} which is a list of arguments passed to the current environment.
It is sometimes useful to access these values when writing programs that are run from command line.
Many programs are written to execute differently based on the various arguments and options specified at execution.
Here is an example.
\begin{lstlisting}
import sys

def square(n):
    return n*n
        
if __name__ == '__main__':
    print sys.argv[0]
    n = float(sys.argv[1])
    print square(n)
\end{lstlisting}
When we run from the command line with a single argument, the code will print the name of the program along with the square of the number passed as the first argument.
If we execute the following script from the command line as follows:
\begin{lstlisting}[style=ShellInput]
python echo.py 4
\end{lstlisting}
We should get the following output.
\begin{lstlisting}[style=ShellOutput]
echo.py
16.0
\end{lstlisting}

\begin{info}
\li{sys.argv} should only be used for the most simple of command line argument parsing.
Python has another module in the standard library, \li{argparse}, which is many times more powerful for accepting and parsing complex command line arguments.  This module allows you to build user-friendly command line interfaces.  Using \li{argparse} is the recommended way to parse command line arguments.
\end{info}

The check \li{if __name__ == '__main__'} is an interesting and very useful bit of code.
When Python executes a script, a few special variables get set before anything gets executed.
If a script is being run as the main module, its \li{__name__} variable gets the value \li{__main__}.  Any imported modules have \li{__name__} set to the module's name.
Therefore, we can check to see if our script is being executed and not imported by some other module by checking if \li{__name__} has the value of \li{__main__}.  We can use this to modify the behavior of the script.

\section*{\texttt{math} Module}
The \li{math} module and its companion, \li{cmath} (for complex numbers), are very useful modules.
Common mathematical functions are defined in these modules, including \li{cos}, \li{sin}, \li{log}, and \li{sqrt}.
These functions wrap around the functionality of the C math library.
\begin{lstlisting}
import math
math.sin(4)
\end{lstlisting}

\begin{problem}
Import the \li{math} module and \li{cmath} module. Write a function that prints out the results of $\sqrt{5}$ for both complex and floating point variants of the appropriate function.  What are the results for $\sqrt{-5}$?
\end{problem}

\section*{\texttt{random} Module}
The \li{random} module contains many helpful functions for obtaining random numbers.
Python's random number generator is adequate for most cases where security isn't critical.  It will generate seemingly random behavior.
Some of the more commonly used functions of the \li{random} are demonstrated below.
\begin{lstlisting}
import random

# get a random integer from interval [5, 12]
random.randint(5,12)

# get a random integer from a range of integers [5, 12)
random.randrange(5, 12)

# get a random element of a sequence.
random.choice("This is a sentence")

# get a random sample of length n from a sequence
random.sample(range(50), 10)

# shuffle a sequence in place
random.shuffle(range(15))
\end{lstlisting}
The \li{random} module has functions that can sample from a variety of different statistical distributions such as: uniform, normal, beta, gamma, exponential, etc.

\section*{\texttt{csv} Module}
Comma separated value (CSV) files are commonly used for exchanging data between databases and tables. 
Python has a very useful module for reading and writing data as comma separated values.
The \li{csv} module provides \li{reader} and \li{writer} objects.
There are also analogous \li{DictReader} and \li{DictWriter} objects that use dictionaries for handling data.

Using these reader and writer objects, we can define the format of our CSV file.  Contrary to the name, CSV files can be delimited with any character.  Tabs and spaces are two other popular delimiting characters.
\begin{lstlisting}
# set the delimiter to tabs
csv_reader = csv.reader(csv_file, delimiter='\t')
\end{lstlisting}

We can become very specific about dialects.
For example, we can define the characters that separate fields, terminate lines, escape special characters, and enclose strings.
The \li{csv} module refers to these special settings as \emph{dialects}.
The module comes with two dialects ready to use, excel and excel-tab.
\begin{lstlisting}
# change the formatting dialect to CSV
csv_reader = csv.reader(csv_file, dialect='excel')
# modify formatting characters
csv_reader = csv.reader(csv_file, quotechar='*', lineterminator='\n')

# custom dialect
class MyDialect(csv.Dialect):
    delimiter = '|'
    quotechar = '*'
    doublequote = True
    skipinitialspace = False
    lineterminator = '\n'
    quoting = csv.QUOTE_MINIMAL
# using our custom dialect
csv_reader = csv.reader(csv_file, dialect=MyDialect)
# finally we can register a dialect with the csv module
csv.register_dialect("MyDialect2", delimiter='&', quotechar='@')
csv_reader = csv.reader(csv_file, dialect='MyDialect2')
\end{lstlisting}

For example, to print the contents of a CSV file, \li{test.csv}, we would do the following.
\begin{lstlisting}
import csv

# open test.csv as read-only
with open('test.csv', 'r') as csv_file:
    # create csv reader object
    csv_reader = csv.reader(csv_file)
    # we can now work with just the reader object
    for line in csv_reader:
        print line
\end{lstlisting}

Writing with a CSV \li{writer} object is very similar to writing with a regular file object.
The following code demonstrates how this may be done.
\begin{lstlisting}
contents = [["Column 1", "Column 2", "Column 3"],
            [0,1,2], [3, 2, 1], [4,5,2], [68, 38, 99]]
            
# open test_out.csv as a write-only file
# this will overwrite test_out.csv if it exists!
with open('test_out.csv', 'w') as csv_file:
    # create a csv writer object
    csv_writer = csv.writer(csv_file)
    for record in contents:
        # write rows using the csv writer object
        csv_writer.writerow(record)
\end{lstlisting}

\section*{\texttt{timeit} Module}
This module is used to time the execution of small bits of Python code.
It is usually good to time lines of code in Python by using this module because it avoids a number of common pitfalls in measuring execution time.
IPython's \li{\%timeit} magic function is a wrapper around this module.

\begin{problem}
For most timing situations, we rely on IPython's \li{\%timeit} function.
Since this is a special function only available inside IPython, we will write a more general timer that works anywhere with any function.
The solution to this problem will be useful in other labs where you will be asked to time the execution of your coded solutions.
Write a function that will time the execution of another function.
You will need to use the \li{timeit} module.
Your timing function should accept as its arguments: a function, $f$, the arguments for $f$, the keyword arguments for $f$, a number of repeats, and a number of loops.
Your function should return the minimum runtime for one call of the function.

Because of the way that Python's \li{timeit} module works, we can either evaluate a string of Python code or use a \emph{callable} function with no arguments.  
For this problem, we will use the the callable function approach.
This essentially means we have to wrap the function we are timing and all of its arguments into a function object that can be called by \li{timeit}.
This wrapping fixes the arguments of the function so we can call it without any arguments later.
This is done by declaring a Python \li{lambda}, or temporary, anonymous  function, which takes no arguments.  \li{pfunc} is a wrapper function for $f$ because its primary job is to call $f$ with little or no additional computation.
In our program, we use \li{pfunc} only to modify how we call $f$.
\begin{lstlisting}
pfunc = lambda: f(*args, **kwargs)
\end{lstlisting}
where \li{args} is a tuple of arguments and \li{kwargs} is a dictionary of keyword arguments to the function, $f$.
You can refresh your memory of functions and their arguments and keyword arguments in sections 4.7.1-4.7.4 of the official Python tutorial.
\end{problem}

\section*{\texttt{collections} Module}
This module defines several specialized data structures to use in addition to the built-in Python data structures.

Named tuples are designed to help improve code readability in some cases.
Standard tuples in Python are accessed by index while named tuples allow access via index or by a field name.

A double-ended queue, or deque (pronounced ``deck''), can be thought of as a deck of cards.
Inserting and removing elements from either end is very efficient.
Python's deque implementation only allows insertions at the left and right ends of the data structure (which is standard for deques).
This differs from a list, which allows insertions anywhere, but is very inefficient for all but right end insertions.
 
Counter objects are very efficient at counting items.  They behave like a Python dictionary.  Counts are allowed to be any integer including 0 and negative values.
 
Ordered dictionaries are exactly like standard dictionaries except for one important difference.
Ordered dictionaries remember the order in which key-value pairs were added to the data structure.
When iterating over an ordered dictionary, the items are returned in the order they were added from first to last.

Default dictionaries are a very convenient way to set a default value for all new keys in a dictionary.
While this can be done with standard dictionaries using the \li{setdefault()} method, using a default dictionary is simpler and faster.

\begin{problem}
Write two functions that will rotate the elements of a deque and a list respectively.
To rotate, remove elements from the right end one by one and insert them on the left end.
Compare the timings you obtain from a deque and a list of 10000 elements.
\end{problem}

\begin{problem}
Write a function that takes in an integer maxInt and an integer n.
Make a list of random integers between 0 and maxInt of length $n$, then use a Counter object to count how times each number appears in the list.
Return a dictionary where the keys are the distinct integers in the list and values are the frequency of the integer.
\end{problem}

\section*{\texttt{itertools} Module}
There is a very powerful library in the Python Standard Library that is built around the concept
of generators and iterators.  The functions in \li{itertools} are designed to be used as
building blocks in larger functions.  These functions are fast and memory efficient.

\subsection*{Generators}
Before discussing this module, let's briefly understand what a generator is.
A generator ``generates'' values.  It is a special type of iterator that yields values on-demand.  Here is a simple example of a generator.
\begin{lstlisting}
def example():
    yield 1
    yield 2
    yield 3
    
g = example()   #initialize the generator
g.next()        #returns 1, the first value
g.next()        #returns 2, the second value
g.next()        #returns 3, the third value
g.next()        #raises a StopIteration exception, no more values to return
\end{lstlisting}
In a generator, the \li{yield} keyword acts like a special \li{return} statement.  
It essentially pauses the execution of the generator and returns a value.
When a generator is created, it simply returns a generator object.
These generator objects have a \li{next()} method, which will request the next value from the generator.
Calling \li{next()} on a generator object resumes execution in the generator until the next yield statement or the generator finishes.

When are generators helpful? 
If you encounter the situations below, consider trying to solve 
your problem using generators.
Generators have proven to be very useful in these situations.
\begin{itemize}
\item \emph{Iterating through only part of a sequence.}
It is inefficient to create an entire sequence if we know that we will not need all of it.
Representing the sequence as a generator could possibly avoid excess memory use and excess computation.
\item \emph{Iterating through a sequence once.} Consider the statement 
\li{sum([i for i in range(1000) if i\%2 == 0])}.
We are creating two sequences just to iterate through them once and never use them again.
We can make this more efficient using generators.
\li{sum(i for i in xrange(1000) if i\%2 == 0)}
Notice that we have used syntax similar to a list comprehension.
The line \li{(i for i in xrange(1000) if i\%2 == 0)} will define a generator object similar to the list made by \li{[i for i in xrange(1000) if i\%2 == 0]}.
The solution using generators will often execute faster, but it will almost always be more memory efficient.  Consider using generators for any function that reduces a sequence to a single value.  Examples of such functions are \li{min()}, \li{max()}, and \li{sum()}.
\item \emph{Calculating large sequences.}  The sequence must be stored somewhere in computer memory.
If the sequence is large, we could exhaust all available memory.
\item \emph{Calculations involving infinite sequences.}  Pre-computed sequences are necessarily finite.  We cannot create a list that stores all natural numbers, but we can create a generator that returns the next natural number every time it is called.
\end{itemize}

\subsection*{Useful Generators in \texttt{itertools}}
The \li{itertools} module contains three main types of generators.
There are infinite generators, shortest sequence generators, and combinatoric generators.
Some of the most used generators are summarized in table \ref{table:populargens}.  The examples are from the Python documentation.
\begin{table}
\begin{tabular}{|l|l|}
\hline
Generator & Example \\
\hline
\li{chain()} & \li{chain('ABC', 'DEF') --> A B C D E F} \\
\li{compress()} & \li{compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F} \\
\li{islice()} & \li{islice('ABCDEFG', 2, None) --> C D E F G} \\
\li{imap()} & \li{imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000} \\
\li{izip()} & \li{izip('ABCD', 'xy') --> Ax By} \\
\li{product()} & \\
\li{permutations()} & \\
\li{combinations()} & \\
\li{combinations_with_replacement()} & \\
\hline
\end{tabular}
\caption{Popular generators in \li{itertools} module.}
\label{table:populargens}
\end{table}

We encourage you to view the documentation for \li{itertools} on the Python website.
The documentation for \li{itertools} also includes various recipes for other useful generator functions.
Feel free to look through the documentation \url{http://docs.python.org/2/library/itertools.html}.

\begin{problem}
You have been tasked to write a simulator that will simulate a hunger games tournament.
In this problem you will be using your cumulative knowledge of the standard library to write a simulator.

You solution should accept a single argument from the command line that is a filename.  All the output you generate in your program will be written to this file.

You are provided with two files, a text file and a CSV file.
The text file has a list of events, one per line.
The CSV file has two columns of names.
The first column are the male tributes, the second column the female tributes.

First, create a named tuple that will contain information about each of the tributes such as their name, district, and gender.

You will need to randomly pair the male and female tributes (read from the CSV file) together to form 12 pairs.

To simulate the game, you will need to do at least the following.
For each day of the simulation, randomly choose the events from the list of events you read from the text file.
Each tribute will experience one event per day.
To determine the survival of a given tribute, randomly generate a number between 0 and 1 (probably with a uniform or Gaussian distribution).  If the random number is greater than a certain threshold, then the tribute survives their event for that day.

Your goal is to use the standard library as much as possible.
To pass off, you must use the standard library for the following parts.
\begin{itemize}
\item Accepting filename (sys)
\item Generating random numbers (random)
\item Pairing tributes (collections, itertools, random)
\item Loading the data (csv, file I/O)
\item Simulating the games (file I/O, random, itertools)
\end{itemize}

Stop the simulation when there is at most one surviving tribute.
Print the winner to standard output.

A sample output for the last two days would like
\begin{lstlisting}[style=ShellOutput]
Day 3
Silver Herriot experienced Tracker Jackers and survived.
Hammil Odinshoot experienced Wild Deer and died.
End of Day 3
Canon fired 1 times

Day 4
The final tribute was the girl from District 4: Silver Herriot
\end{lstlisting}
The final result would be printed to the console
\begin{lstlisting}[style=ShellOutput]
The final tribute was the girl from District 4: Silver Herriot
\end{lstlisting}
\end{problem}

