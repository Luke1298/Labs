\lab{Data Structures II}{Data Structures II}
\label{lab:Python_Datastructures2}

\objective{Implement and use tree data structures}

\section*{Introduction}

Trees are data structures for organizing and finding data.
They are more difficult to build than linked lists.
However, once they are built they can search for and find data very quickly.
For example, the computational complexity of finding a node in a linked list is $O(n)$.
A well built tree will find a node with a complexity of $O(\log{n})$

\section*{Recursion}

Recursion is a problem solving technique that is useful for working with trees.
A recursive function is a function that can call itself.
Such a function will call itself until a base case is reached.
Compare, for example, the following two methods for calculating the $nth$ Fibonacci number.

\begin{lstlisting}
def iterative_fib(n):
	"""An iterative method that returns the nth Fibonacci number"""

	# Initialize an array for the Fibonacci numbers and set the first entries to 1
	fib_array = np.zeros(n)
	fib_array[0] = 1
	fib_array[1] = 1
	for i in range(2,n):
		# Starting at the third entry, calculate the next number by adding
		# the previous two entries in the array. 
		fib_array[i] = fib_array[i-1] + fib_array[i-2]
	return fib_array[n]

def recursive_fib(n):
	if n == 1 or n == 0:
		# Base case
		return 1
	else
		# Call recursive_fib on smaller numbers until the 
		# base case is reached.
		return recursive_fib(n-1) + recursive_fib(n - 2)
\end{lstlisting}

\begin{problem}
Many iterative solutions may be posed as recursive solutions.
One example is searching in a linked list.
Rewrite the following iterative function for finding data in a linked list so that it is recursive.
\begin{lstlisting}
def search(linkedlist, data):
	current = linkedlist.head
	while current.data != data:
		if current.next is None:
			raise ValueError(str(data) + " is not in the list."
		else:
			current = current.next
	return current
\end{lstlisting}
\end{problem}


\section*{Trees}

A tree in a directed graph with no cycles.
The first node in a tree is called the root.
The root node point to other nodes, called children.
Each child node in turn points to its children.
This continues on each branch until its end is reached.
A node with no children is called a leaf node.

A linked list is a tree.
The head node is the root node, and it has one child node.
That child node also has one child node, which in turn has one child.
This continues until the end of the list.

Other kinds of trees may be more complicated.
See Figure \ref{fig:Tree}.

\begin{figure}
\caption{Include some examples of trees here.  Probably 3 different examples displayed horizontally.}
\end{figure}

\section*{Binary Search Trees}

A binary search tree is a tree that allows each node to have up to two children, called \li{left} and \li{right}.
Binary search trees are used for storing ordered data.
The left child of a node will have data that is less than the node's data.
The right child's data will be greater.
See Figure \ref{fig:BST} for some examples of binary search trees.
In practice, binary search tree nodes have attributes that keep track of their data, children, and their parent.

\begin{lstlisting}
#A binary search tree node class found in BST.py

class BSTNode(object):
	"""Node class for a binary search tree."""

	def __init__(self, data):
		"""Constructor for a BSTNode. Data is required, but the other attributes
		will be set when the node is added to the tree.
		"""
		self.data = data
		self.left = None 	# This will be less than self.data
		self.right = None 	# This will be more than self.data
		self.parent = None
		
		#This is a utility attribute used by the __repr__ function in the BST class.
		#It may be ignored for now.
		self.visited = False


	def __repr__(self):
		return str(self.data)
\end{lstlisting}

A binary search tree class will have an attribute pointing to its root and an attribute keeping track of the number of nodes in the tree.

\begin{lstlisting}
# A binary search tree class found in BST.py

class BST(object):

	def __init__(self):
		"""Constructor for a binary search tree object. The root and
		size attributes are initialized"""
		self.root = None
		self.size = 0

\end{lstlisting}


\subsection*{Finding in a Binary Search Tree}

Many tree algorithms are easier to understand using recursion.
For example, finding a node in a binary search tree can be done recursively.
Starting at the root, we check if the data we are looking for matches the current node.
If it does not, then if the data is less than the current node's data we search again on the left child.
If the data is greater, we search on the right child.
This process continues until the data is found or, in the case that the data is not in the tree, an empty child is searched.
See Figure \ref{fig:BST_Search} for an example.
Carefully read the following code for understanding.
Similar techniques will be used for subsequent methods.

\begin{lstlisting}
# The find method for a binary search tree.  Found in BST.py

def find(self, data):
	"""Recursive find method for a binary search tree object. If
	the data is not in the BST then a ValueError is raised. Otherwise,
	the node that contains the data is returned.
	"""

	If self.root is None: return

	def _step(current, data):
		"""Recursive method for finding data.  Start at the root, and 
		traverse the tree until the node with the data is found.
		"""
			if data < current.data:
				if current.left is None:
					# Return None if a dead end is reached
					return
				else:
					# Recursively call _step on the left child
					_step(current.left, data)
			elif data > current.data:
				if current.right is None:
					return
				else:
					# Recursively call _step on the right child
					_step(current.right, data)
			elif data == current.data:
				return current
			else:
				# Return None if a dead end is reached.
				return

	# Start the search at the root node
	found_node = _step(self.root, data)
	if found_node is None:
		raise ValueError(str(data) + " is not in the tree."
	return found_node
\end{lstlisting}

Recall that finding in a linked list requires traversing the list until the data is found.
At each step of a binary search tree, we are able to eleminate some of the data that needs to be searched.
This yields dramatically faster search times over linked lists.

\begin{problem}
The \li{lab5_data} module has a method called \li{load_data}.
This method returns two objects: a linked list and a binary search tree of a random permutation of the numbers from 1 to 100000.
Each object as a \li{find} method that returns the node that contains the data that the \li{find} method receives as an argument.
Write a method that generates 50 random numbers between 1 and 100000, finds them in the given data structures, and returns the average search time for each.
\end{problem}

\subsection*{Inserting in a Binary Search Tree}

To insert new data into a binary search tree, a leaf node is added at the right location.
To insert in the correct location, the correct parent node is found.
We find the correct parent by using recursion, similarly to how we implemented the \li{search} function.  See the following pseudocode.
Once the correct parent is found, the new node is added as the left or right child of the parent.
See \ref{fig:insertion} for an example.
\begin{comment}
\begin{lstlisting}
"""Pseudocode for finding the correct parent of a new node

find the parent of node, data
	if data < node.data:
		if node.left is not None 
			find the parent of node.left, data
		else:
			return node
	if data > node.right:
		if data > node.data:
			if node.right is not None:
				find the parent of node.right, data
			else:
				return node
"""
\end{lstlisting}
\end{comment}
\begin{problem}
Implement the \li{insert} method in the \li{BST} class.
To accomplish this, implement the \li{_find_parent} method using recursion.
Once \li{_find_parent} is implemented, use it to find the correct parent given new data.
Once the correct parent is found, determine whether the new data will belong to a left or a right child.
Then, add the new node as the correct child and connect it to its parent.
\end{problem}

\subsection*{Deleting in a Binary Search Tree}

Deleting nodes from a binary search tree is more difficult than searching and inserting.
While inserting always creates a new leaf node, any kind of node may be deleted.
This leads to several different cases that must be considered.

\subsubsection*{Deleting a leaf node}

Recall that a leaf node has no children.
Thus, removing a leaf node will not affect the remaining tree structure.
To remove a leaf node, we only need to remove the pointer to it in its parent node.

\begin{lstlisting}
"""Pseudocode for removing a leaf node
if the target node does not have children:
	if the target's data is smaller than its parent's data:
		set the parent's left child to None
	else:
		set the parent's right child to None
"""
\end{lstlisting}

\subsubsection*{Deleting a node with one child}

In Python we delete an object by removing all references to it.
Thus, if we remove all references to a node that has children, it will be deleted.
Since all the references to the deleted node's children are in that node, it's children will also be deleted.
Similarly, its children's children will be deleted.
This process will continue for all of the deleted node's descendents.
Thus, a large swath of the tree can be deleted if we simply remove references to the node that we want to delete.

Call the node we want to delete the target node.
To avoid deleting all of the target's descendents, we point the target's parent to an appropriate successor.
If the target has only one child, then that child is the successor.
Then, the target has no references pointing to it, and so is deleted.
The target's child is pointed to by the target's parent, and so it remains in the tree.

\begin{lstlisting}
"""Pseudocode for removing a node with one child
if the target node has one child:
	if target.parent.right is the target:
		set parent's right child to the target's child.
	if target.parent.left is the target:
		set parent's left child to the target's child.
"""
\end{lstlisting}

\subsubsection*{Deleting a node with two children}

Things get signicantly more complicated if the target node has two children.
To delete this kind of node, first we must find it's immediate in-order predecessor.
The predecessor is the node with the largest data that is smaller than the target's data.
It may be found by moving to the left child of the target, and then to the right for as long as possible.

Once the predecessor is found, we switch it with the target node.
This can be done by switching the data values for the target and its predecessor.
Now the target node is a node with at most one child, and may be deleted in the same way.
If the predecessor was chosen appropriately, then the binary search tree structure will be maintained once the deletion is finished.

\begin{lstlisting}
"""Pseudocode for removing a node with two children.

find the predecessor:
	set the current node to be target.left
	set current to be current.right until there is no right child
	return current.

Swap the target and the predecessors data.
Remove the node that node that has the target data (it will only have one child).
"""
\end{lstlisting}
\begin{problem}

Implement the \li{delete} method in the \li{BST} class.
Make sure to cover the following cases:
\begin{enumerate}
\item Deleting a single node
\item Deleting the root node with one child
\item Deleting the root node with two children
\item Deleting a non-root node with no children
\item Deleting a non-root node with one child
\item Deleting a non-root node with two children.
\end{enumerate}

\end{problem}

\section*{AVL Trees}

Binary search trees are a good way of organizing ordered data so that it is quickly searchable.
However, pathologies may arise when data are inserted.
This is best demonstrated by inserting already ordered data into a binary search tree.
Since the data is already ordered, each child will only have one child, and we end up with a linked list.
Less bad problems arise when one branch of the tree becomes much longer than the others, leading to longer search times.
This negates all of our work in building the binary search tree.

An AVL tree is a tree that prevents any one branch from getting longer than the others.
It accomplishes this by periodically ``balancing'' the branches as nodes are added.
See Figure \ref{fig:avl_balance}
The algorithm that does this is beyond the scope of this text.
We refer the reader to Jeff's book for a full treatment.
We will explore the advantages of an AVL tree in the following exercise.

\begin{problem}
The \li{Lab5_data} module has a method called \li{load_words} that returns a list of several thousand english words.
The \li{Lab5_spec} module has an implementation of an AVL tree that inherits from a working \li{BST} class.
Insert each word into an instances of the \li{BST} and \li{AVL} classes.
Write a method called \li{test_words} that searches for 50 random words in each object and returns their average search times.
\end{problem}

