\lab{Unix Shell}{Shell}
\label{lab:Shell}
% Written by Tanner Christensen, Summer 2015
% If more content in the Problems is needed, in Problem 6, we could add:
%    "edit count_files.py to exclude the files in the test directory"

\objective{Introduce the basics of the Unix Shell commands and integrate Unix Shell commands with Python}

Unix was first developed by AT\&T Bell Labs in the 1970s. In the 1990s, Unix became the foundation of Linux and MacOSX. The majority of servers are written in Linux, so having a knowledge of Unix shell commands allows us to interact with these servers. 

The more you learn about Unix, you will find it is easy to learn but difficult to master. We will build a foundation of simple file system navigation, job control, and basic system remote access. We will address some of the basics in detail and also include lists of commands that are worth learning.

\section*{File System}
\subsection*{Navigation}

Begin by opening the Terminal. The text you see in the upper left of the Terminal window is called the \emph{prompt}. We will begin using three very basic commands: \li{pwd}, \li{ls}, and \li{cd}. The \li{pwd} command stands for print working directory. The \li{ls} command lists the files and subdirectories within the working directory. The \li{cd} command changes the working directory.

%The only reason this problem exists is to make sure it is VERY clear not to mess with the Shell-Lab directory

\begin{problem}
Using these commands, navigate to the \li{Shell-Lab} directory provided with this lab. We will use this directory for the remainder of the lab. Use the \li{ls} command to list the contents of this directory. NOTE: You will find a directory within this directory called \li{test} that is availabe for you to experiment with the concepts and commands found in this lab. The other files and directories are necessary for the exercises we will be doing, so take care not to modify them.
\end{problem}

\subsection*{Flags}
Most commands can be customized using flags. The \li{ls} command has dozens of optional flags. Table \ref{table:ls_flags} contains some of the most common flags for the \li{ls} command.

\begin{table}
\begin{tabular}{l|l} 
Flags & Description
\\ \hline 
\li{-a} & Do not ignore hidden files and folders \\ 
\li{-l} & List files and folders in long format \\ 
\li{-r} & reverse order while sorting \\
\li{-s} & print item name and size \\
\li{-t} & Sort output by last modified \\ 
\li{-R} & Print files and subdirectories recursively \\ 
\li{-S} & Sort by size \\ 
\end{tabular} 
\caption{Common flags of the \li{ls} command.}
\label{table:ls_flags} 
\end{table} 

Multiple flags can be combined as one flag. For example, if we wanted to list all the files in a directory in long format sorted by last time modified, we would use \li{ls -a -l -t} or \li{ls -alt}. To view the reference manual for any command, use \li{man}. For example, to view the reference manual for the \li{ls} command, use \li{man ls}.

\subsection*{Other Useful Commands}
Table \ref{table:other_commands} contains a list commonly-used commands and their uses. Many of these commands will be needed throughout this lab and in any typical session with the Unix shell. After some of the commands are flags listed in square brackets that are worth exploring using \li{man}. We highly recommend experimenting with all these commands to become familiar with them. Remember you may freely experiment with these commands in the \li{test} directory.

\begin{lstlisting}
$ cd test
$ touch data.txt				# create new file data.txt
$ mkdir New						# create new directory New
$ ls							# list items in test directory
New 	data.txt
$ cp data.txt New/				# copy data.txt to New directory
$ cd New/						# enter the New directory
$ ls							# list items in New directory
data.txt
$ mv data.txt new_data.txt		# rename data.txt new_data.txt
$ ls							# list items in New directory
 new_data.txt
$ cd ..							# Return to test directory
$ rm -rv New/					# Remove New directory and its contents
 removed 'New/data.txt'
 removed directory: 'New/'
$ clear							# Clear terminal screen
\end{lstlisting}

\begin{table}
\begin{tabular}{l|l} 
Commands & Description
\\ \hline 
\li{clear} & Clear the terminal screen \\
\li{cp file1 dir1} & Create a copy of \li{file1} and move it to \li{dir1} \\
\li{cp file1 file2} & Create a copy of file1 and name it file2 \\
\li{cp -r dir1 dir2} & Create a copy of dir1 and all its contents into \li{dir2} \\
\li{df dir1} & Display available disk space in file system containing \li{dir1} \\
\li{du dir1} & Display disk usage within \li{dir1} [\li{-a}, \li{-h}] \\
\li{mkdir dir1} & Create a new directory named \li{dir1} \\
\li{mkdir -p path/to/new/dir1} & Create \li{dir1} and all intermediate directories \\
\li{mv file1 dir1} & Move \li{file1} to \li{dir1} \\
\li{mv file1 file2} & Rename \li{file1} as \li{file2} \\
\li{rm file1} & Delete \li{file1} [\li{-i}, \li{-v}] \\
\li{rm -r dir1} & Delete \li{dir1} and all items within \li{dir1} [\li{-i}, \li{-v}] \\
\li{touch file1} & Create an empty file named \li{file1} \\
\li{.} & Current directory \\
\li{..} & Parent directory \\
\li{\~} & Home directory \\
\li{/} & Root directory \\
\end{tabular} 
\caption{Other useful commands dealing with the file system.}
\label{table:other_commands} 
\end{table} 

\begin{problem}
Inside the \li{Shell-Lab} directory, delete the \li{Audio} folder along with all its contents. Create \li{Documents}, \li{Photos}, and \li{Python} directories.
\end{problem}

\subsection*{Wildcards}
As we are working in the file system, there will be times that we want to perform  the same command to a group of similar files. For example, if you needed to move   all text files within a directory to a new directory, the naive way to do this would be to move each text file individually. However, this same result can be achieved using \emph{wildcards}. We use wildcards as placeholder text.  The two wildcards we use most are \li{*} and \li{?}. The \li{*} wildcard represents any string and the \li{?} wildcard represents any character. Though these wildcards can be used in almost every Unix command, they are particularly useful when dealing with files. See Table \ref{table:wildcards}

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{*.txt} & All files that end with \li{.txt}. \\
\li{image*} & All files that have \li{"image"} as the first 5 characters. \\
\li{*py*} & All files that contain \li{"py"} in the name. \\
\li{doc*.txt} & All files of the form \li{doc1.txt}, \li{doc2.txt}, \li{docA.txt}, etc. \\
\end{tabular} 
\caption{Common uses for wildcards.}
\label{table:wildcards} 
\end{table} 

\begin{problem}
Within the \li{Shell-Lab} directory, there are many files. We will organize these files into directories. Using wildcards, move all the \li{.jpg} files to the \li{Photos} directory, all the \li{.txt} files to the \li{Documents} directory, and all the \li{.py} to the \li{Python} directory. You will see a few other folders in the \li{Shell-Lab} directory. Do not move any of the files within these folders at this point.
\end{problem}

\section*{Searching the File System}
There are two powerful commands we use for searching through our directories. The \li{find} command is used to find files or directories in a directory hierarchy. The \li{grep} command is used to find lines matching a string. More specifically, we can use \li{grep} to find words inside files. We will provide a basic template in Table \ref{table:find} for using these two commands and leave it to you to explore the uses of the other flags.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{find dir1 -type f -name "word"} &  Find all files in \li{dir1} with the name \li{"word"} \\ 
 & (\li{-type f} is for files \li{-type d} is for directories)\\
\li{grep -nr "word" dir1} & Find all occurances of \li{"word"} within the files inside \li{dir1} \\ 
 & (\li{-n} lists the line number and \li{-r} performs a recursive search)\\
\end{tabular} 
\caption{Commands using \li{find} and \li{grep}.}
\label{table:find} 
\end{table} 

\begin{problem}
In addition to the .jpg files you have already moved into the \li{Photots} folder, there are a few other .jpg files in a few other folders within the \li{Shell-Lab} directory. Find where these files are using the \li{find} command and move them to the \li{Photos} folder.
\end{problem}

\subsection*{Pipes and Redirects}
Unix becomes even more versatile and powerful when you chain multiple commands together. This is accomplished using \emph{pipes}. Rather than printing the output of a command, the output is passed, or \emph{piped}, to the next command. Two commands are piped together using the \li{|} operator. To demonstrate the power of pipes, we will first introduce a few commands that allow us to view the contents of a file in Table \ref{table:print}

In the first example below, the \li{cat} command output is piped to \li{wc -l}. The \li{wc} command stands for word count. This command can be used to count words or lines. The \li{-l} flag tells the \li{wc} command to count lines. Therefore, this first example counts the number of lines in \li{assignments.txt}. 
In the second example below, the command lists the files in the current directory sorted by size in descending order. For details on what the flags in this command do, consult \li{man sort}.

\begin{lstlisting}
$ cd Shell-Lab/Files/Feb
$ cat assignments.txt | wc -l
9

$ ls -s | sort -nr
12 project3.py
12 project2.py
12 assignments.txt
 4 pics
total 40
\end{lstlisting}
%$

In the previous example, we pipe the contents of \li{assignments.txt} to \li{wc -l} using \li{cat}. When working with files specifically, it is better to use \emph{redirects}. The same output from the first example above can be achieved by running the following command:

\begin{lstlisting}
$ wc -l < assignments.txt
9
\end{lstlisting}
%$

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{cat} & Print the contents of a file in its entirety \\ 
\li{more} & Print the contents of a file one page at a time \\
\li{less} & Like more, but you can navigate forward and backward \\
\li{head} & Print the first 10 lines of a file \\
\li{head -nK} & Print the first K lines of a file \\ 
\li{tail} & Print just the last 10 lines of a file \\
\li{tail -nK} & Print the last K lines of a file \\
\end{tabular} 
\caption{Commands for printing contents of a file}
\label{table:print} 
\end{table} 

If you are wanting to save the resulting output of a command to a file, use \li{>} or \li{>>}. The \li{>} operator will overwrite anything that may exist in the output file whereas \li{>>} will append the output to the end of the output file. For example, if we want to append the number of lines in \li{assignments.txt} to \li{word_count.txt}, we would run the following commmand:

\begin{lstlisting}
$ wc -l < assignements.txt >> word_count.txt
\end{lstlisting}
%$

Since \li{grep} is used to print lines matching a pattern, it is also very useful to use in conjunction with piping. For example, \li{ls -l | grep root} prints all files associated with the root user.

\begin{problem}
The \li{words.txt} file in the \li{Documents} directory contains a list of words that are not in alphabetical order. Write the number of words in \li{words.txt} and an alphabetically sorted list of words to \li{sortedwords.txt} using pipes and redirects. Save this file in the \li{Documents} directory. Try to accomplish this with a total of two commands or fewer.
\end{problem}

\section*{File Security}
To begin, run the following command while inside the \li{Shell-Lab} directory:

\begin{lstlisting}
$ cd Shell-Lab/Python
$ ls -l 
-rw-rw-r-- 1 username groupname 194 Aug  5 20:20 calc.py
-rw-rw-r-- 1 username groupname 373 Aug  5 21:16 count_files.py
-rwxr-xr-x 1 username groupname  27 Aug  5 20:22 mult.py
-rw-rw-r-- 1 username groupname 721 Aug  5 20:23 project.py

\end{lstlisting}

Notice the first column of the output. The first character denotes the type of the item whether it be a normal file, a directory, a symbolic link, etc. The remaining nine characters denote the permissions associated with that file. Specifically, these permissions deal with reading, wrtiting, and executing files. There are three categories of people associated with permissions. These are the user (the owner), group, and others. For example, look at the output for \li{mult.py}. The first character \li{-} denotes that \li{mult.py} is a normal file. The next three characters, \li{rwx} tell us the owner can read, write, and execute the file. The next three characters \li{r-x} tell us members of the same group can read and execute the file. The final three characters \li{--x} tell us other users can execute the file and nothing more.

Permissions can be modified using the \li{chmod} command. There are two different  ways to specify permissions, \emph{symbolic permissions} notation and \emph{octal permissions} notation. Symbolic permissions notation is easier to use when we want to make small modifications to a file's permissions.  See Table \ref{table:symbolic}.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{chmod u+x file1} & Add executing permissions to user (owner) \\
\li{chmod g-w file1} & Remove writing permissions from group \\
\li{chmod o-r file1} & Remove reading permissions from other other users \\
\li{chmod a+w file1} & Add writing permissions to everyone \\
\end{tabular} 
\caption{Symbolic permissions notation}
\label{table:symbolic} 
\end{table} 

Octal permissions notation is easier to use when we want to set all the permissions as once. The number 4 corresponds to reading, 2 corresponds to writing, and 1 corresponds to executing. See Table \ref{table:octal}.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{chmod 760 file1} & Sets \li{rwx} to user, \li{rw-} to group, and \li{---} to others \\
\li{chmod 640 file1} & Sets \li{rw-} to user, \li{r--} to group, and \li{---} to others \\
\li{chmod 775 file1} & Sets \li{rwx} to user, \li{rwx} to group, and \li{r-x} to others \\
\li{chmod 500 file1} & Sets \li{r-x} to user, \li{---} to group, and \li{---} to others \\
\end{tabular} 
\caption{Octal permissions notation}
\label{table:octal} 
\end{table} 

The commands in Table \ref{table:chown} are also helpful when working with permissions.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{chown} & change owner \\
\li{chgrp} & change group \\
\li{getfacl} & view all permissions of a file in a readable format. \\
\end{tabular} 
\caption{Other commands when working with permissions}
\label{table:chown} 
\end{table} 

\section*{Scripts}

A shell script is a series of shell commands saved in a file. Scripts are useful when we have a process that we do over and over again. The following is a very simple script:

\begin{lstlisting}
#!/bin/bash
echo "Hello World"
\end{lstlisting}

Save this script as \li{hello}. Note that no file type is necessary. The first line starts with \li{"#\!"}. This is called the \emph{shebang} or \emph{hashbang} character sequence. It is followed by the absolute path to the \li{bash} interpreter. If we  were unsure where the \li{bash} interpreter is saved, we run \li{which bash}.  To execute a script, type the script name preceded by \li{./}

\begin{lstlisting}
$ ./hello
bash: ./hello: Permission denied

# Notice that you do not have permission to execute this file. This is by default
$ ls -l hello
-rw-rw-r-- 1 username groupname 31 Jul 30 14:34 hello

$ chmod u+x hello
$ ./hello   
Hello World
\end{lstlisting}

You can do this same thing with Python scripts. All you have to do is change the path following the shebang. To see where the Python interpreter is stored, run \li{which python}.

\begin{problem}
In the \li{Python} directory you will find \li{count_files.py}. \li{count_files.py} is a python script that counts all the files within the \li{Shell-Lab} directory. Modify this file so it can be run as a script and change the permissions of this script so the user and group can execute the script.
\end{problem}

If you would like to learn how to run scripts on a set schedule, consider researching \emph{cron jobs}.

\section*{Job Control}
Let's say we had a series of scripts we wanted to run. If we knew that these would take a while to execute, we may want to start them all at the same time and let them run while we are working on something else. In the Table \ref{table:jobs}, we have listed some of the most common commands used in job control. We strongly encourage you to experiment with these commands. In the \li{Scripts} directory, you will find a \li{five_secs} and a \li{ten_secs} script that takes five seconds and ten seconds to execute respectively. These will be particularly useful as you are experimenting with these commands. 

\begin{lstlisting}
$ ./ ten_secs &
$ ./ five_secs &
$ jobs
[1]+  Running		./ten_secs &
[2]-  Running		./five_secs &
$ kill %2
[2]-  Terminated	./five_secs &
$ jobs
[1]+  Running		./ten_secs &
\end{lstlisting}
%$

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{COMMAND \&} & Adding an ampersand to the end of a command \\
& runs the command in the background \\
\li{bg \%N} & Restarts the Nth interrupted job in the background \\
\li{fg \%N} & Brings the Nth job into the foreground \\
\li{jobs} & Lists all the jobs currently running \\
\li{kill \%N} & Terminates the Nth job \\
\li{ps} & Lists all the current processes \\
\li{Ctrl-C} & Terminates current job \\
\li{Ctrl-Z} & Interrupts current job \\
\li{nohup} & Run a command that will not be killed if the user logs out \\
\end{tabular} 
\caption{Job control commands}
\label{table:jobs} 
\end{table} 

\begin{problem}
In addition to the \li{five_secs} and \li{ten-secs} scripts, the \li{Scripts} folder contains three scripts that will each take about a forty-five seconds to execute. 
Execute each of these commands in the background so all three are running at the same time. To verify all scripts are running at the same time, write the output of \li{jobs} to a new file \li{log.txt} saved in the \li{Scripts} directory.
\end{problem}

\section*{Python Integration}
To this point, we have barely scratched the surface of all the functionality that Unix has to offer. However, the tools and commands we have addressed so far provide us with a foundation of the basics. 
Using the \li{subprocess} module in Python, we can call Unix commands. By combining Python and the Unix commands, our toolset is automatically broadened.

There are two functions in particular within the \li{subprocess} module we will use. When wanting to run a Unix command, use \li{subprocess.call()}. 
When wanting to run a Unix command and be able to store and manipulate the output, use \li{subprocess.check_output()}. 
These functions have a keyword argument \li{shell} that defaults to \li{False}. We want to set this argument to \li{True} to run the command in the Unix shell.

\begin{lstlisting}
$ cd Shell-Lab/Documents
$ python
>>> import subprocess
>>> subprocess.call("ls -l", shell=True)
-rw-rw-r-- 1 username groupname  142 Aug  5 20:20 assignments.txt
-rw-rw-r-- 1 username groupname  427 Aug  5 20:21 doc1.txt
-rw-rw-r-- 1 username groupname  326 Aug  5 20:21 doc2.txt
-rw-rw-r-- 1 username groupname  612 Aug  5 20:21 doc3.txt
-rw-rw-r-- 1 username groupname  298 Aug  5 20:21 doc4.txt
-rw-rw-r-- 1 username groupname 1027 Aug  5 20:23 review.txt
-rw-rw-r-- 1 username groupname  920 Aug  5 23:50 words.txt
>>> files = subprocess.check_output("ls -l", shell=True)
>>> files
'-rw-rw-r-- 1 username groupname  142 Aug  5 20:20 assignments.txt\n-rw-rw-r-- 1 username groupname  427 Aug  5 20:21 doc1.txt\n-rw-rw-r-- 1 username groupname  326 Aug  5 20:21 doc2.txt\n-rw-rw-r-- 1 username groupname  612 Aug  5 20:21 doc3.txt\n-rw-rw-r-- 1 username groupname  298 Aug  5 20:21 doc4.txt\n-rw-rw-r-- 1 username groupname 1027 Aug  5 20:23 review.txt\n-rw-rw-r-- 1 username groupname  920 Aug  5 23:50 words.txt\n'
>>> files.split('\n')
['-rw-rw-r-- 1 username groupname  142 Aug  5 20:20 assignments.txt',
 '-rw-rw-r-- 1 username groupname  427 Aug  5 20:21 doc1.txt',
 '-rw-rw-r-- 1 username groupname  326 Aug  5 20:21 doc2.txt',
 '-rw-rw-r-- 1 username groupname  612 Aug  5 20:21 doc3.txt',
 '-rw-rw-r-- 1 username groupname  298 Aug  5 20:21 doc4.txt',
 '-rw-rw-r-- 1 username groupname 1027 Aug  5 20:23 review.txt',
 '-rw-rw-r-- 1 username groupname  920 Aug  5 23:50 words.txt',
 '']
# To get rid of the last empty string in the list
>>> files.pop()
''

# Now that we have a list object, we can manipulate and analyze this data in Python. We can make it even more accessible by splitting the lines again
>>> files = [line.split() for line in files]
\end{lstlisting}

\begin{problem}
Create a \li{Shell} class in Python. Write a \li{find_file} method that will search for a filename starting in the current directory using the \li{find} command. Write a \li{find_word} method that finds a given word within the contents of the current directory using the \li{grep} command. For both these functions, return a list of filepaths.
\end{problem}

\begin{problem}
Write a method for the \li{Shell} class that recursively finds the \li{n} largest files within a directory. Have a keyword argument for the directory that defaults to the current directory. Be sure that your function only returns files. Hint: To view the size of a file \li{file1}, you can use \li{ls -s file1} or \li{du file1}
\end{problem}

\section*{Secure Shell}

Let's say you are working for a company with a file server. Hundreds of people need to be able to access the content of this machine, but how is that possible? Or say you have a script to run that requires some serious computing power. How are you going to be able to access your company's super computer to run your script? We do this through \emph{Secure Shell} (SSH).

SSH is a network protocol encrypted using public-key cryptography. The system we are connecting \emph{to} is commonly referred to as the \emph{host} and the system we are connecting \emph{from} is commonly referred to as the \emph{client}. Once this connection is established, there is a secure tunnel through which commands and files can be exchanged between the client and host.

\begin{lstlisting}
$ whoami    # use this to see what your current login is
client_username
$ ssh host_username@hostname

# You will then be prompted to enter the password for host_username

$ whoami    # use this to verify that you are logged into the host
host_username
\end{lstlisting}
%$

Now that you are logged in on the host computer, all the commands you execute are as though you were executing them on the host computer.

\subsection*{Secure Copy}

When we want to copy files between the client and the host, we use the \emph{secure copy} command, \li{scp}. The following commands are run when logged into the client computer.

\begin{lstlisting}
# copy filename to the host's system at filepath
$ scp filename host_username@hostname:filepath

#copy a file found at filepath to the client's system as filename
$ scp host_username@hostname:filepath filename

# you will be prompted to enter host_username's password in both these instances 
\end{lstlisting}

\begin{problem}
\emph{This problem is optional depending on the circumstances of the student.}
You will either need a partner for this problem or have access to a username on another computer. Experiment with SSH. Verify that you can connect from a client to a host. Copy a few files between the host and the client.
\end{problem}

\subsection*{Generating SSH Keys (Optional)}
If there is a host that we access on a regular basis, typing in our password over and over again can get tedious. By setting up SSH keys, the host can identify if a client is a trusted user without needing to type in a password. If you are interested in experimenting with this setup, a Google search of "How to set up SSH keys" will lead you to many quality tutorials on how to do so.

\section*{Archiving and Compression}
In file management, the terms archiving and compressing are commonly used interchangeably. However, these are quite different. To archive is to combine a certain number of files into one file. The resulting file will be the same size as the group of files that were archived.
To compress is to take a file or group of files and shrink the file size as much as possible. The resulting compressed file will need to be extracted before being used.

The \li{ZIP} file format is the most popular for archiving and compressing files. If by chance the \li{zip} command is not installed on your system, you can download it by running \li{sudo apt-get install zip}. Note that you will need to have administrative rights to download this package. To unzip a file, use \li{unzip}.

\begin{lstlisting}
$ zip zipfile.zip directory
<verbose output>

# use -l to view contents of zip file
$ unzip -l zipfile.zip
<content output>

$ unzip zipfile.zip
<verbose output>
\end{lstlisting}
%$

While the \li{ZIP} file format is more popular on the Windows platform, the \li{tar} utility is more common in the Unix environment. The following commands use \li{tar} to archive the files and \li{gzip} to compress the archive. 

Notice that all the commands below have the \li{-z}, \li{-v}, and \li{-f} flags. The \li{-z} flag calls for the \li{gzip} compression tool, the \li{-v} flag calls for a verbose output, and \li{-f} indicates the next parameter will be the name of the archive file. 

\begin{lstlisting}
# use -c to create a new archive
$ tar -zcvf <archive> <files/directory> 
<create>

# use -t to view contents
$ tar -ztvf <archive>                    
<view>

# use -x to extract
$ tar -zxvf <archive>                   
<extract>
\end{lstlisting}
%$


\section*{Web Related}

In many of its applications, \li{wget} and \li{curl} perform the same tasks. Both of these commands are used to download content from the internet. Most the differences between \li{wget} and \li{curl} are beyond the scope of this book. 
At its most basic, \li{curl} is the more robust tools of the two and \li{wget} can download recursively. Though we will provide examples using \li{wget}, know that much of the same functionality can be performed using \li{curl}.

\subsection*{Downloading files using Wget}

When we want to download a single file, we just need the URL for the file we want to download. Running the command below will downlad a JPEG image of a person writing on a chalkboard. Similarly, you can download PDF files, HTML files, and other content simply by providing a different URL. 

\begin{lstlisting}
$ wget http://acme.byu.edu/wp-content/uploads/2013/07/0906-13-00903.jpg
<output> 
\end{lstlisting}
%$

The following are also useful commands using \li{wget}.

\begin{lstlisting}
# Download files from URLs listed in urls.txt
$ wget -i urls.txt
<verbose output> 

# Download in the background
$ wget -b URL
<verbose output>

# Download something recursively
$ wget -r --no-parent URL
<verbose output>

\end{lstlisting}
%$

\section*{sed and awk}
\li{sed} and \li{awk} are two different scripting languages in their own right. Like Unix, these languages are easy to learn but difficult to master. It is very common to combine Unix commands and \li{sed} and \li{awk} commands. We will address the basics, but if you would like more information, see <url>

\subsection*{Formatting output using awk}
Earlier in this lab we mentioned \li{ls -l} and as we have seen, this outputs lots of information. Using \li{awk}, we can select which fields we wish to print. Suppose we only cared about the file name and the permissions. We can get this output by running the following command.

\begin{lstlisting}
$ ls -l | awk ' {print $1, $9} '
\end{lstlisting}
%$

Notice we pipe the output of \li{ls -l} to \li{awk}. Whenever we are wanting to call a command using \li{awk}, we always use quotation marks. Note it is a common mistake to forget to add these quotation marks. Inside these quotation marks, commands always take the same format.

\begin{lstlisting}
awk ' <options> {<actions>} '
\end{lstlisting}

In the examples we will be exploring in this lab, we will not be using any of the options, but we will address various actions. For those interested in learning what options are available see <url>. In our first example, we use the \li{print} action. The \li{\$1} and \li{\$9} mean that we are going to print the first and ninth fields.

Beyond specifying which fields we wish to print, we can also choose how many characters to allocate for each field. In the \li{Documents} directory, you will find a \li{people.txt} file that we will use for the following examples.

\begin{lstlisting}
# contents of people.txt
$ cat people.txt
male,John,23
female,Mary,31
female,Sally,37
male,Ted,19
male,Jeff,41
female,Cindy,25

# Change the field separator (FS) to "," at the beginning of execution (BEGIN)
# By printing each field individually proves we have successfully separated the fields
$ awk ' BEGIN{ FS = "," }; {print $1,$2,$3} ' < people.txt
male John 23
female Mary 31
female Sally 37
male Ted 19
male Jeff 41
female Cindy 25

# Format columns using printf so everything is in neat columns in order (gender,age,name)
$ awk ' BEGIN{ FS = ","}; {printf "%-6s %2s %s\n", $1,$3,$2} ' < people.txt
male   23 John
female 31 Mary
female 37 Sally
male   19 Ted
male   41 Jeff
female 25 Cindy
\end{lstlisting}

The statement \li{"\%-6s \%2s \%s\\n"} formats the columns of the output. This says to set aside six characters left justied, then two characters right justified, then print the last field to its full length.

\begin{problem}
Inside the \li{Documents} directory, you should find a file named \li{files.txt}. This file contains details on approximately one hundred files. The different fields in the file are separated by tabs. Using \li{awk}, \li{sort}, pipes, and redirects, write a file named \li{date_modified.txt} with the following specifications:
- in the first column, print the date the file was modified
- in the second column, print the name of the file
- sort the file from newest to oldest based on the date last modified
All this can be accomplished using one command.
\end{problem}

We have barely scratched the surface of what \li{awk} can do. Performing an internet search for ``awk one-liners'' will give you many additional examples of useful commands you can run using \li{awk}.

\subsection*{Printing Specific Lines Using sed}

\subsection*{Find and Replace Using sed}
