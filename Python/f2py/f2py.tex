\lab{Python}{F2PY}{F2PY}
\label{lab:f2py}
\objective{Learn how to use F2PY, especially for wrapping Fortran code involving arrays.}

Here we will explore another simple way to access external code from Python.
Various utilities exist to do this, and many are specialized for specific tasks.
F2PY is a utility that can be used to automatically wrap Fortran subroutines so that they are callable from Python.
It is included with NumPy and in most cases does not usually require heavy configuration for use.
The primary requirement for using F2PY is a working Fortran compiler.
If you have access to GFortran, the Fortran equivalent of gcc, it should work well.

\section*{Examples}

F2PY is very simple to use.
Many simple Fortran files can be compiled \emph{automatically} without any hand-written interfaces between languages.
Windows 64 bit users, if you encounter errors, see the Windows 64 bit install guide.
We will start by wrapping the Fortran function we wrapped as a part of Lab \ref{lab:cythonwrap}.
Here we will wrap the subroutine in unmodified form.
In Lab \ref{lab:cythonwrap} we modified the Fortran file to make it callable from C.
F2PY will take care of this for us so that we can wrap the subroutine directly.
Here is the file in its unmodified form:
\lstinputlisting[style=fromfile, language=Fortran, name=ftridiag.f90]{./ftridiag/ftridiag.f90}
We can wrap this file by running the following in our terminal:
\begin{lstlisting}[style=ShellInput]
f2py -c ftridiag.f90 -m ftridiag
\end{lstlisting}
Depending on the way your system is configured, the following command may be needed
\begin{lstlisting}[style=ShellInput]
python f2py.py -c ftridiag.f90 -m ftridiag
\end{lstlisting}
We can also tell F2PY to pass additional optimization flags to the compiler using the \li{--opt} flag, as in:
\begin{lstlisting}[style=ShellInput]
f2py -c ftridiag.f90 -m ftridiag --opt="-O3 -march=native"
\end{lstlisting}

Running these commands will create a file called \li{ftridiag.pyd} on a Windows computer or \li{ftridiag.so} on a Linux or Mac based computer.
This file is a Python module that is linked against the compiled Fortran code.
All the details about array type, shape, size, etc. have been infered by F2PY.
We can test the module in nearly the same way we tested the Fortran version of the tridiagonal algorithm that we wrapped as part of Lab \ref{lab:cythonwrap}.
Here is the file for testing that with the corresponding changes.
\lstinputlisting[style=fromfile, name=ftridiag_test.py]{./ftridiag/test.py}
\begin{info}
For our example here we compiled the subroutine by itself instead of compiling an entire module.
If the function were a part of a Fortran module \li{tridiag} F2PY would have made it available to us as \li{ftridiag.tridiag.ftridiag}.
\end{info}

\begin{warn}
When working with arrays that have more than one dimension, F2PY expects arrays that are Fortran ordered, i.e. arrays that have their columns stored in contiguous blocks.
By default it will raise an error if it receives a C-contiguous array, though it can be configured to silently make a copy instead.
You can make a Fortran ordered array by taking the transpose of a C contiguous array.
You will have to be careful about this if you are wrapping Fortran code using the default settings.
\end{warn}

Again, similar to working with Cython, we can also create a \li{setup.py} file to create our Python extension module.
The following \li{setup.py} file will do the same thing as the terminal command used above.
\lstinputlisting[style=fromfile, name=ftridiag_setup.py]{./ftridiag/setup.py}

\begin{problem}
Included with this lab is a pure-fortran version of the \li{fssor} subroutine that you wrapped in Lab \ref{lab:cythonwrap}.
Wrap it again using f2py.
Write a \li{setup.py} file as shown above.
When wrapping automatically in this way, F2PY was able to infer that \li{m} and \li{n} are the dimensions of the array.
On the other hand, we have not defined default vaues for the tolerance and the maximum number of iterations, so those must still be passed in as arguments.
\end{problem}

\section*{Detailed Compilation Steps}
Though F2PY can be used automatically as we have just shown, it can be used to generate more carefully customized wrappers for Fortran functions and subroutines.
When compiling an extension, F2PY performs two basic steps that are accessible to users:
\begin{itemize}
\item Create a \li{.pyf} signature file defining the interface for the Fortran subroutines
\item Compile the Fortran code and use Python's C API to make an extension module that calls it in the way defined in the signature file.
\end{itemize}
If we want a more specific interface for the Fortran code we are wrapping we can generate the signature file, then modify it so that F2PY will make a Python function with the desired calling signature.

Consider the \li{ftridiag} subroutine used above.
We can have F2PY generate a signature file based on the contents of the file \li{ftridiag.f90} by using the command
\begin{lstlisting}[style=ShellInput]
f2py ftridiag.f90 -h ftridiag.pyf
\end{lstlisting}
The signature file created by F2PY is
\lstinputlisting[style=fromfile, language=Fortran, name=ftridiag.pyf]{./ftridiag/ftridiag.pyf}
This looks almost like a function signature in Fortran, except that F2PY has accounted for the fact that \li{n} is one more than the dimension of the first array.

% Wrap a C function using f2py to teach about signature files.

% Wrap a LAPACK function (dgtsv?), have them do it too.

% Discuss how memory layout affects performance.

% Discuss programmer time value.
