\lab{Python}{Object Oriented Programming}{Object Oriented Programming}
\label{lab:OOP}
\objective{Teach how to use OOP in Python and illustrate the uses of OOP in programming graphical user interfaces}

\section*{Programming Paradigms}

Writing readable code is one of the best skills a programmer can learn.
It is one thing to write a program that works, but another to write one that another person can understand.
Organization is key to clarity, and common ways of organizing code are called \emph{programming paradigms}.
Obeject Oriented Programming (OOP) is one of these paradigms.
It allows us to model and replicate organization and structure from real life.
OOP also allows us to create a ``black box'' that users can interface with without understanding the inner workings.

Because of these advantages, Obeject Oriented Programming has become a prominent and important programming paradigm used to simplify, organize, and clarify code. 
In this lab we will first learn how use OOP with Python adn implement some simple examples. 
Then we will learn about Graphical User Interfaces (GUI) and OOP's uses in implementing them.


\begin{comment}
A way of organizing a program is often called a ``paradigm."

Paradigms are designed to create better code by structuring or organizing the code in a more meaningful way.
Code without any structure is often referred to as ``spaghetti code.''
Spaghetti can be very easy to write, but very difficult to understand or modify.
\emph{Structured programming} emphasizes the use of programming structures to select or repeat the execution of blocks of code.
It is good practice to structure your programs in such a way that they are easy to understand, extend, or reuse.
Making extensive use of procedures (or subfunctions) is a characteristic of \emph{procedural programming}.
The work of the program is done in the subfunctions with one main function supervising the calling of each subfunction.

Another important, albeit specialized, paradigm is \li{object oriented programming} (or OOP).
The concept of object oriented programming is to model a problem as the interaction of a collection of objects.
There are many other paradigms such as declarative, event-driven, and array programming.
\end{comment}



\section*{Fundamental Concepts}

\begin{comment}
At its core, object oriented programming relies on the manipulation and coordination of objects.
An object represents a piece of code that tracks a state and provides methods for discovering or altering the state.


There are a few concepts that define object oriented programming

\begin{itemize}

\item Abstraction - appropriate representation of states and data

\item Encapsulation - independent behavior

\item Inheritance - relations between objects

\end{itemize}

The general advantage of using these concepts is that it helps with organizing code.
``Abstraction" permits the presentation of only necessary details about an object to the user.
For example, when we ask someone if they own a computer, we can use abstraction to ask the question ``Do you own a computer?'' rather than asking about each and every combination of hardware that we could classify as a computer.
Inheritance helps us easily achieve this abstraction.
We could have an object called \li{Computer}.
Various brands would then subclass, or inherit, the properties of \li{Computer}.
We could continue by having each product line inherit from their respective brands, until we arrive at the product level.
Then each individual product would represent an instantiation of that product's class.
%Need graphic
Encapsulation means each function contains all of the data it needs to calculate a result.
Encapsulation is used to avoid the use of global data structures and makes managing data involved in computation more convenient.
\end{comment}
At its core, object oriented programming relies on the manipulation and coordination of objects.
An object contains variables and provides methods for discovering or altering those variables.
Python, like most modern programming languages, supports object oriented programming concepts.
However, unlike other programming languages everything in Python is an object.
Strings, lists, and even integers are examples of objects in Python, which is why they have \emph{methods}, functions that belong spiecifically to those objects.
We can create our own objects in Python by defining a \emph{class}.
A class is a blueprint that describes how to create an object.

\begin{lstlisting}
class Backpack(object):
    pass
\end{lstlisting}

We now have a class \li{Backpack} which contains nothing.
We can create \li{Backpack} objects by running something like \li{b = Backpack()}, but we can't really do anything with them.
The variable \li{b} is now an \emph{instance} of type \li{Backpack}.
Let's define an initial state for our object.

\begin{lstlisting}
class Backpack(object):
    def __init__(self):
        self.color = 'black'
\end{lstlisting}

Let's explain what's going on here.
First, we defined a method.
It can be called on instances of our class but on nothing else.
The \li{__init__} method is defined for all objects and is executed immediately after the object is created.
Its purpose is to set the initial state of the object.
In ours, we are telling it to set the backpack's color to black.
The \li{self} is a reference to the current instance of the class.
All class methods take a reference to the current instance of the class as their first argument.
In our backpack object, we set the color to black.
Thus all backpack objects will have the color black.
Instead, let's allow the user to choose a different color, but we will still make black the default.

\begin{lstlisting}
class Backpack(object):
    def __init__(self, color='black'): 
    '''color is now an argument that our function will take in. 
    The color = 'black' means that if nothing is given, the color is automatically set to black.'''
        self.color = color
\end{lstlisting}

We can instantiate a \li{Backpack} object of the color purple or if we do not specify than it will default to black.

\begin{lstlisting}
b = Backpack(color='purple')
a = Backpack()
print b.color #prints `purple'
print a.color #prints `black'
\end{lstlisting}

The variable \li{self.color} is an instance variable.
It is defined for a particular instance of a backpack.
Finally, lets add some methods and additional state variables.

\begin{lstlisting}
class Backpack(object):
    def __init__(self, color='black'):
        self.color = color
        self.contents = []
        '''This creates an empty list when a backpack is created. 
        It will store the backpack's contents.'''
        
    def put(self, item):
        self.contents.append(item) 
        '''This adds ``item'' into our contents list. self.contents accesses the instance variable.
         Then .append() uses the list class's append function to add ``item'' to the end of the list.'''
        
    def take(self, item):
        return self.contents.pop(self.contents.index(item)) 
        ''' The index() method returns the index of ``item''
        Then the pop() method removes the item at the given index.'''
        
\end{lstlisting}

Now that we have defined methods for our \li{Backpack} class, we can interact with it.


\begin{lstlisting}
b = Backpack(color='green')
print b.color #prints `green'
b.color = 'turqoise' # we can change an instance variable at any time
print b.color #prints `turqoise'
print b.contents # prints `[]'
b.put(5)
b.put(3)
b.put(9)
b.put(1)
print b.contents #prints `[5, 3, 9, 1]'
b.take(3)
print b.contents #prints `[5, 9, 1]'
\end{lstlisting}

\begin{problem}
Create a class called \li{People} that allows us to keep track of professors and students.
Each instance of \li{People} should have a variable that can be set to `Student' or `Professor' and a list to keep track of thier classes.
Include a method that allows us to add a class and one to take away a class.
\label{School}
\end{problem}

One ability that our classes are missing is the ability to interact with common operations and functions.
Python's objects such as strings, lists, integers can interact with \li{print},  $ =, - , >, \text{and} <$.
Right now, if we used \li{print} on an instance of \li{Backpack}, Python would not know how to interpret it as a string.
Similarly, Python would not know how to compare one backpack to another using $ =, - , >, \text{and} <$.
We can fix this by using \emph{magic methods}
Magic methods are just methods like the \li{put()} and \li{take()} we gave our \li{Backpack} class, except that we don't call them directly on an instance of the class like how we said \li{b.put(5)}.
Magic methods can be recognized by using underscores in thier names.

Let's add two magic methods to \li{Backpack}. 
The \li{__repr__} method tells Python how to represent our class as a string. 
Then we will be able to call \li{print b} and it will print our backpack, b.
The \li{__lt__} methods will implement the $<$ operator, letting us compare two backpacks.

\begin{lstlisting}
class Backpack(object):
    def __init__(self, color='black'):
        self.color = color
        self.contents = []
        
    def put(self, item):
        self.contents.append(item)
        
    def take(self, item):
        return self.contents.pop(self.contents.index(item)) 
        
    def __repr__(self):
        return str(self.contents)
        '''Tells the class how to represent the Backpack object as a string.
        Returns a string version of the contents list'''
        
   def __lt__(self, other):
   	return len(self.contents) < len(other.contents)
   	''' Compares the length of the two backpack's contents lists. `''
\end{lstlisting}

The other comparison operators are implemented in a similar way.
Now let's test our magic methods.

\begin{lstlisting}
b = Backpack(color = 'green')
c = Backpack(color = 'yellow')
b.put(2)
b.put(5)
c.put(7)
c.put(1)
c.put(8)
print b # prints `[2,5]'
print c # prints `[7,1,8]'
if b < c: # Should return True, sending us into the if branch.
	print 'b is less than c'

\end{lstlisting}

For more information on creating methods and magic methods read the official Python docs, at \url {http://docs.python.org/2/reference/datamodel.html} or another helpful reference at \url{http://www.rafekettler.com/magicmethods.html}.
This information may be helpful in solving Problem \ref{prob:complexNum}.

\begin{problem}
Create a \li{ComplexNumber} object that supports the basic operations of a complex number.
You must implement methods that will compare, add, subtract, multiply, divide, and conjugate complex numbers.
Also, implement a \li{norm()} method that will calculate the euclidean distance between two points on the complex plane.
\label{prob:complexNum}
\end{problem}

\section*{Graphical User Interfaces}

GUI's are a powerful tool for creating applications that users can interface with.
PySide is a helpful library to build GUI's.
From PySide, we will used two modules, QtGui and QtCore.
QtCore has functions that will help us implement the inner workings of our GUI while QtGui will allows us to implement the graphics and interface. 
To walk through the main ideas behind building a GUI, we will create an interface for our \li{Backpack} class from earlier.

\begin{lstlisting}
from PySide import QtGui, QtCore

class BackpackInterface(QtGui.QWidget): #This class inherits from the QWidget class found in the QtGui module.
	def __init__(self, home = ``about:blank''):
		super(BackpackInterface, self).__init__() 
		'''Calls the __init__ method from QWidget, the super class of BackpackInterface.'''
\end{lstlisting}

\emph{Widgets} are what allows the magic to happen in GUIs.
When you push a button or enter text, it is the widgets that realize it and cause changes.
This happens through sending and catching signals.
We can specify where a widget throws a signal and who catches it.
When a signal is caught, we can then have it call a function that will process the input.


\begin{problem}
Create a simple graphical user interface that will solve the quadratic formula given the necessary parameters.
Make the GUI look as below.
\begin{figure}[H]
\centering
\begin{subfigure}[b]{.49\textwidth}
\includegraphics[width=\textwidth]{quadratic_view.png}
\end{subfigure}
\begin{subfigure}[b]{.49\textwidth}
\includegraphics[width=\textwidth]{quadratic_view2.png}
\end{subfigure}
\end{figure}
The widgets that you will need are: \li{QDoubleSpinBox}, \li{QLabel}, \li{QGridLayout}, and \li{QVBoxLayout}.
You can view the documentation for these classes including all methods and signals at \url{http://qt-project.org/doc/qt-4.8/classes.html}
\label{prob:quadCalc}
\end{problem}


\section*{Specifications}

The following is a guideline for your solutions.

\begin{lstlisting}
import sys
from Pyside import QtGui, QtCore

class People(object):
	pass
	
class ComplexNumber(object):
	pass
	
class QuadraticCalculator(QtGui.QWidget):
	pass
\end{lstlisting}

