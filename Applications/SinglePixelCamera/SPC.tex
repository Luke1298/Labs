\lab{Application}{Single Pixel Camera}{Single Pixel Camera}
\label{lab:SPC}

\objective{You build a single pixel camera that to take pictures of 2d and 3d tesselations.}

\section*{Single Pixel Camera}
When you look at a picture on a computer screen it is divided into areas called pixels. Each pixel is a square that has a Red-Green-Blue (RGB) color vaule. When a  modern digital camera takes a picture it divides the picture in to pixels and stores the amount red, green, and blue light the comes in at each square.

A single pixel camera treats the whole image as one pixel and thus only stores one RGB value that is the average color value of the whole image.  

\section*{2d images}
In this lab we are going to represent the world as tesselated image. A tesselated image is a tiling with geometric shapes. 

In this lab we assume that $\s{S}$ has a given tesselation $\s{T} = \{F_i\}$, where $F_i$ represents a particular face of our tesselation. Without loss of generality, we will assume that each $F_i$ is a triangle. We will represent the vertices of $F_i$ by $F^j_i$, where $F^j_i$ will be a column vector of length two representing the coordinates of $F_i$.

Recall from mutivarible calculus that the area of a triangle is half the magnitude of the cross product. For $F_i$ this is given by
\begin*{align}
v_1 &= F_i^1 - F_i^0 \\
v_2 &= F_i^2 - F_i^0 \\
A_i &= \frac{1}{2}\big|v_1[0] v_2[1] - v_1[1] v_2[0]\big|
\end*{align}


We represent our signal, in this case our RBG color values, as a vector $s$, where the length of $s$ is the number of faces of our tesselation $\s{T}$. We assume, naturally, that the value of our signal  on the face $F_i$ is exactly the value $s[i]$. We can then, using the areas previously calculated, express the single-pixel measurement of the signal ot the camera as an inner product:
\begin{equation}
A \cdot s = b
\end{equation}
In addition we assume that the total area of the image is equal to the sum of our tesselations. So  
\begin{equation}
\hat{b} = \frac{b}{\sum_i A}
\end{equation}

Then $\hat{b}$ will be the RGB values of the singe pixel.

\begin{problem}
Write a function that takes in $S$, a 3-d array of the vertices of 2d tesselation faces, and $s$ , the RBG values of the each tesselation. Output the RGB value given by the single pixel camera. Below is code to visualize the tesselation and \hat{b}. 
\end{problem}

\begin{lstlisting}
import matplotlib.pyplot as plt
from matplotlib.collections import PolyCollection
# This fucntion plots tesselation, S, with the colors s 
def visualize2d(S,s):
    fig, ax = plt.subplots()
    coll = PolyCollection(S, facecolors=s)
    ax.add_collection(coll)
    ax.autoscale_view()
    plt.show()
\end{lstlisting}
\begin{lstlisting}
#Let b be a 1d array of 3 values representing the RGB values. This plots the color
plt.imshow(np.array([[b]]))
plt.show()
\end{lstlisting}

\section*{Projective Transforms}
Now say that we have a tesselated 3d object and we would like to take a single pixel picture of it.

We begin by selecting a random camera location $c$. The location is selected randomly on a sphere centered at the origin, with norm large enough that the entire surface lies inside the sphere. The camera is assumed to point directly at the origin.

In order to keep the distance of the camera from the origin constanst, this is best done by inputing the spherical coordinates and then changing to rectagular. Recall the that the formula to change polar coordinates to recetagular is 
\[
S(\theta,\phi,r)=(r*\sin(\phi)*\cos(\theta),r*\sin(\phi)*\sin(\theta),r*\cos(\phi))
\theta \in [0,2\pi),\phi \in [0,\pi), r \in [0,\infty)
\]
\begin{problem}
Write a function that changes spherical coordinates to rectagular.
\end{problem}

We then utilize the projective transform to calculate how the camera ``sees'' the faces of the surface. This is a well-known technique, so we will simply state the appropriate equations:

\begin*{align}
t &= \text{acos}(\frac{-c_2}{\|c\|}) \\
w^* &= \begin{bmatrix}
	\frac{c_1}{\|c\|} \\
	\frac{-c_0}{\|c\|} \\
	0
\end{bmatrix} \\
w &= \frac{w^*}{\|w^*\|} \\
\hat{w} &= \begin{bmatrix}
0 & 0 & w_1 \\
0 & 0 & -w_0 \\
-w_1 & w_0 & 0
\end{bmatrix} \\
R &= e^{\hat{w}t} = I + sin(t) \hat{w} + (1-cos(t)) \hat{w}^2 \\
P &= \begin{bmatrix}
R^T & -R^T c \\
0 & 1
\end{bmatrix}
\end*{align}

We can then use the matrix $P$ to transform any point $x$ in homogenous world, in this case homogenous coordinates are created by simply appending 1 to the bottom of a given column vector, coordinates to homogenous camera coordinates $y$ by the equation:
\begin{equation}
Px = y
\end{equation}

\begin{problem}
Write a function that takes in a camera location and outputs the transformation matrix.
\end{problem}

We can then find the projective transform (i.e. how the camera ``sees'' a point) by the equation:
\begin{equation}
P_c(y) = \begin{bmatrix}
\frac{y[0]}{f \cdot y[2]} \\
\frac{y[1]}{f \cdot y[2]}
\end{bmatrix}
\end{equation}

Here $f$ represents the distance from the camera to the image plane, which is essentially an arbitrary constant. I recommend using $f=.5$.

\begin{problem}
Write a function that takes in a transformation matrix, a list of points in world coordinates, and a constant $f$ and outputs the projective transform of the points.
\end{problem}

Now we essentially we have 2d points and we can calculate the areas as we did in the 2d case. Now we have the areas of each face of our tesselation with respect to our camera view. One thing that we need to worry about is the visibility of of the face $F_j$. This constant, for convex surfaces, will either be zero or one. In this case the constant, if the center of the face denoted $Fc_j$ and $r$ is the radius of the tesselation. Then
\[
e_j=||c-Fc_j||_2<\sqrt{||c||_2^2+r^2}
\] 
Where $e_j$ is a constant representing the  the visibility of of the face $F_j$. Then:

\begin{problem}
Write a function that takes in an array of vertices of a tesselation, a camera position and the radius of the tesselation and outputs an array of visibilty constants.
\end{problem}
\begin{equation}
M(j) = A_j \cdot e_j
\end{equation}
Then
\begin{equation}
M \cdot s = b
\frac{b}{\sum_i M} = \hat{b}
\end{equation}
And $\hat{b}$ is the RGB value of a picture taken by the single pixel camera at location $c$.

\begin{problem}
Using the previous problems, write a function that takes in an array of vertices of a tesselation, color values for the faces of the tesselation and a camera position and outputs single pixel RGB value.
\end{problem}

You can extend this for any tesselated object 2d or 3d. The only thing that changes is how you calculate the area of the face (For example shoelace formula gives the area of any simple polygon.) The Projective Transform remains the same. 

\section{Application}
The single pixel camera is used in the field of compressed sensing (though the camera works a little differently than the one you made in this lab)

%\begin{figure}[h]
%\includegraphics[scale = .4]{Kevin_Bacon.jpg}
%\caption{Kevin Bacon.  Image source: Wikipedia.}
%\end{figure}

