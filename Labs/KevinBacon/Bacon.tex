\lab{Breadth-First Search and the Kevin Bacon Problem}{Breadth-First Search and the Kevin Bacon Problem}
\label{lab:SixDegreesKevinBacon}

\objective{Learn to store graphs as adjacency dictionaries, implement a breadth-first search, learn to use NetworkX, and use the parlor game ``the Six Degrees of Kevin Bacon'' as an application to graph theory.}

\section*{Introduction}

Graph theory has many practical applications.
For example, graphs may represent a social network, a communication network, or the internet.
Being able to construct, analyze, and search graphs yields critical insights into the system that the graph represents.

\section*{Graphs in Python}

Graphs can be stored using various kinds of data structures.
In previous labs, we stored trees as linked lists.
For non-tree graphs, perhaps the most common data structure is an adjacency matrix, where each row of the matrix corresponds to a node in the graph and the entries of the row indicate which other nodes the current node is connected to.
For a full treatment fo adjacency matrices, see chapter 2 of the Volume II text.

Another comon graph data structure is an \emph{adjacency dictionary}, a Python dictionary with a key for each node in the graph.
The dictionary values are lists containing the nodes that are connected to the key.
For example, the following is an adjacency dictionary for the graph in Figure \ref{fig:simple_graph}:

\begin{lstlisting}
>>> adjacency_dictionary = {'A':['B', 'C', 'D', 'E'], 'B':['A', 'C'],
'C':['B', 'A', 'D'], 'D':['A', 'C'], 'E':['A']}

# The nodes are stored as the dictionary keys.
>>> print(adjacency_dictionary.keys())
['A', 'C', 'B', 'E', 'D']
\end{lstlisting}

\begin{figure}
\centering
\begin{tikzpicture}[auto,node distance=1.5cm,
 thick,main node/.style={circle,draw}]

  \node[main node] (1) {A};
  \node[main node] (2) [left of=1] {B};
  \node[main node] (3) [above of=1] {C};
  \node[main node] (4) [right of=1] {D};
  \node[main node] (5) [below of=1] {E};

  \path[every node/.style={font=\sffamily\small}]
     (1) edge node [] {} (4)
     	  edge node [] {} (3)
     	  edge node [] {} (5)
     (2) edge node [] {} (1)
     	  edge node []{}(3)
     (3) edge node []{}(4);
\end{tikzpicture}
\caption{A simple graph with five vertices.}
\label{fig:simple_graph}
\end{figure}

% Problem 1: __str__ for Graph class (warmup with dictionaries)
\begin{problem}
Implement the \li{__str__} method in the provided \li{Graph} class.
Print each node in the graph in sorted order, followed by a sorted list of the neighboring nodes separated by semicolons.

(Hint: consider using the \li{join} method for strings.)

\begin{lstlisting}
>>> my_dictionary = {'A':['C', 'B'], 'C':['A'], 'B':['A']}
>>> graph = Graph(my_dictionary)
>>> print(graph)
A: B; C
B: A
C: A
\end{lstlisting}
\end{problem}

\section*{Breadth-First Search}

Many graph theory problems are solved by finding the shortest path between two nodes in the graph.
To find the shortest path, we need a way to strategically search the graph.
Two of the most common searches are depth-first search (DFS) and breadth-first search (BFS).
In this lab, we focus on BFS.
For details on DFS, see the chapter 2 of the Volume II text.

A BFS traverses a graph as follows: begin at a starting node.
If the starting node is not the target node, explore each of the starting node's neighbors.
If none of the neighbors are the target, explore the neighbors of the starting node's neighbors.
If none of those neighbors are the target, explore each of their neighbors.
Continue the process until the target is found.

As an example, we will do a programmatic BFS on the graph in Figure \ref{fig:simple_graph} one step at a time.
Suppose that we start at node $C$ and we are searching for node $E$.

\begin{lstlisting}
# Start at node C
>>> start = 'C'
>>> current = start

# The current node is not the target, so check its neighbors
>>> adjacency_dictionary[current]
['B', 'A', 'D']

# None of these are E, so go to the first neighbor, B
>>> current = adjacency_dictionary[start][0]
>>> adjacency_dictionary[current]
['A', 'C']

# None of these are E either, so move to the next neighbor
# of the starting node, which is A
>>> current = adjacency_dictionary[start][1]
>>> adjacency_dictionary[current]
['B', 'C', 'D', 'E']

# The last entry of this list is our target node, and the search terminates.
\end{lstlisting}

You may have noticed that some problems in the previous approach that would arise in a more complicated graph.
For example, what prevents us from entering a cycle?
How can we algorithmically determine which nodes to visit as we explore deeper into the graph?

\subsection*{Implementing Breadth-First Search}

We solve these problems using a queue.
Recall that a \emph{queue} is a type of limited-access list.
Data is inserted to the back of the queue, but removed from the front.
Refer to the end of the Data Structures I lab for more details.

A queue is helpful in a BFS to keep track of the order in which we will visit the nodes.
At each level of the search, we add the neighbors of the current node to the queue.
The \li{collections} module in the Python standard library has a \li{deque} object that we will use as our queue.

\begin{lstlisting}
# Import the deque object and start at node C
>>> from collections import deque
>>> current = 'C'

# The current node is not the target, so add its neighbors to the queue.
>>> visit_queue = deque()
>>> for neighbor in adjacency_dictionary[current]:
...     visit_queue.append(neighbor)
...
>>> print(visit_queue)
deque(['B', 'A', 'D'])

# Move to the next node by removing from the front of the queue.
>>> current = visit_queue.popleft()
>>> print(current)
B
>>> print(visit_queue)
deque(['A', 'D'])

# This isn't the node we're looking for, but we may want to explore its 
# neighbors later. They should be explored after the other neighbors
# of the first node, so add them to the end of the queue.
>>> for neighbor in adjacency_dictionary[current]:
...     visit_queue.append(neighbor)
...
>>> print(visit_queue)
deque(['A', 'D', 'A', 'C'])
\end{lstlisting}

We have arrived at a new problem.
The nodes $A$ and $C$ were added to the queue to be visited, even though $C$ has already been visited and $A$ is next in line.
We can prevent these nodes from being added to the queue again by keeping a running list of nodes that don't need to be added.
However, not all such nodes are created equal.
For example, $C$ has already been visited, while $A$ is in line to be visited, but hasn't actually been visited yet.
We distinguish between these two types of nodes with two additional lists: \li{visited} and \li{marked}.

Nodes that are in \li{visited} have already been visited by the algorithm.
If we make it a Python \li{list}, \li{visited} will also keep track of the order in which we visited the nodes in the graph.
Nodes that are in \li{marked} have been added to the queue, but have not been visited yet.
Since the ordering doesn't matter for which nodes are marked, we make \li{marked} a Python \li{set}.
If we check both of these groups at each step of the algorithm, the previous problems are avoided.

\begin{lstlisting}
>>> current = 'C'
>>> marked = set()
>>> visited = list()
>>> visit_queue = deque()

# Visit the start node C.
>>> visited.append(current)

# Add the neighbors of C to the queue.
>>> for neighbor in adjacency_dictionary[current]:
...     visit_queue.append(neighbor)
...     # Since each neighbor will be visited, add them to marked as well.
...     marked.add(neighbor) 
...
# Move to the next node by removing from the front of the queue.
>>> current = visit_queue.popleft()
>>> print(current)
B
>>> print(visit_queue)
['A', 'D']

# Visit B. Since it isn't the target, add B's neighbors to the queue.
>>> visited.append(current)
>>> for neighbor in adjacency_dictionary[current]:
...     visit_queue.append(neighbor)
...     marked.add(neighbor) 
...

# Since C is visited and A is in marked, the queue is unchanged.
>>> print(visit_queue)
deque(['A', 'D'])
\end{lstlisting}

% Problem 2: general BFS
\begin{problem}
Implement the \li{search} method in the \li{Graph} class using a BFS.
Start from a specified node and proceed until all nodes in the graph have been visited.
Return the list of visited nodes.
If the starting node is not in the adjacency dictionary, raise a \li{ValueError}.
\end{problem}

% Problem 3: general DFS (Optional)
\begin{problem}
(Optional) Create a new method called \li{DFS} in the \li{Graph} class
that mimics the \li{search} method, but uses a DFS instead of a BFS.

(Hint: this can be done by changing a single line of the BFS code.)
\end{problem}

\section*{Shortest Path}

In a BFS, as few neighborhoods are explored as possible before finding the target.
Therefore, the path taken to get to the target must be the shortest path.

Examine again the graph in Figure \ref{fig:simple_graph}.
The shortest path from $C$ to $E$ is start at $C$, go to $A$, and end at $E$.
During a BFS, $A$ is visited because it is one of $C$'s neighbors, and $E$ is visited because it is one of $A$'s neighbors.
If we knew programmatically that $A$ was the node that visited $E$, and that $C$ was the node that visited $A$, we could retrace our steps to reconstruct the search path.

To implement this idea, initialize a new dictionary before starting the BFS.
When a node is added to the visit queue, add a key-value pair to the dictionary where the key is the node that is visited and the value is the node that is visiting it.
When the target node is found, step back through the dictionary until arriving at the starting node, recording each step.

\begin{problem}
Implement the \li{shortest_path} method in the \li{Graph} class using a BFS.
Begin at a specified starting node and proceed until a specified target is found.
Return a list containing the node values in the shortest parth from the start to the target (including the endpoints).
If either of the inputs are not in the adjacency graph, raise a \li{ValueError}.
\end{problem}

\section*{Network X}

NetworkX is a Python package for creating, manipulating, and exploring large graphs.
It contains a graph object constructor as well as methods for adding nodes and edges to the graph.
It also has methods for recovering information about the graph and its structure.

\begin{lstlisting}
# Create a new graph object using networkX
>>> import networkx as nx
>>> nx_graph = nx.Graph()

# There are several ways to add nodes and edges to the graph.
# One is to use the add_edge method, which creates new edge
# and node objects as needed, ignoring duplicates
>>> nx_graph.add_edge('A', 'B')
>>> nx_graph.add_edge('A', 'C')
>>> nx_graph.add_edge('A', 'D')
>>> nx_graph.add_edge('A', 'E')
>>> nx_graph.add_edge('B', 'C')
>>> nx_graph.add_edge('C', 'D')
# Nodes and edges are easy to access
>>> print(nx_graph.nodes())
['A', 'C', 'B', 'E', 'D']

>>> print(nx_graph.edges())
[('A', 'C'), ('A', 'B'), ('A', 'E'), ('A', 'D'), ('C', 'B'), ('C', 'D')]

# NetworkX also has its own shortest_path method, implemented
# with a bidirectional BFS (starting from both ends)
>>> nx.shortest_path(nx_graph, 'C', 'E')
['C', 'A', 'E']

# With small graphs, we can visualize the graph with nx.draw()
>>> from matplotlib import pyplot as plt
>>> nx.draw(nx_graph)
>>> plt.show()
\end{lstlisting}

% Problem 5: Intro to NetworkX
\begin{problem}
Write a \li{convert_to_networkx} function that accepts an adjacency dictionary.
Create a \li{networkx} object, load it with the graph information from the dictionary, and return it.
\end{problem}

\section*{The Kevin Bacon Problem}

\href{http://oracleofbacon.org/help.php}{``The 6 Degrees of Kevin Bacon"} is a well-known parlor game.
The game is played by naming an actor, then trying to find a chain of actors that have worked with each other leading to Kevin Bacon.
For example, Samuel L. Jackson was in the film \emph{Captain America: The First Avenger} with Peter Stark, who was in \emph{X-Men: First Class} with Kevin Bacon.
Thus Samuel L. Jackson has a ``Bacon number'' of 2.
Any actors who have been in a movie with Kevin Bacon have a Bacon number of 1.

% Problem 6: BaconSolver constructor and shortest path
\begin{problem}
Write a \li{BaconSolver} class to solve the Kevin Bacon problem.

The provided \texttt{movieData.txt} file contains data from about 13,000 movies made over the course of several years.
A single movie is listed on each line, followed by a sequence of actors that starred in it.
The movie title and actors' names are separated by a `/' character.
The actors are listed with last name first, followed by their first name.

The provided \li{bacon_data} module has a function called \li{parse} that generates an adjacency dictionary from a specified file.
Used with \texttt{movieData.txt}, \li{parse} generates a dictionary where each key is a movie title and each value is a list of the actors appearing in the movie.

Implement the constructor of \li{BaconSolver} so it accepts a filename to pull data from.
Get the dictionary generated by \li{parse}.
Store the collection of actors in the dictionary as a class attribute (avoid duplicates).
Convert the dictionary to a NetworkX graph and store it as another class attribute.
This graph will have actors, connected to movies, connected to other actors.

Finally, use NetworkX to implement the \li{path_to_bacon} method.
Accept start and target values (actor names) and return a list with the shortest path from start to target.
Make Kevin Bacon the default target.
If either of the specified actors are not in the stored set of actors, raise a \li{ValueError}.

\begin{lstlisting}
>>> baconator = BaconSolver("movieData.txt")
>>> baconator.path_to_bacon("Jackson, Samuel L.")
['Jackson, Samuel L.', 'Captain America: The First Avenger', 'Stark,
Peter', 'X-Men: First Class', 'Bacon, Kevin']
\end{lstlisting}

\begin{warn}
Because of the size of the dataset, \textbf{do not} attempt to visualize the graph with \li{nx.draw}.
The visualization tool in NetworkX is only effective on relatively small graphs.
In fact, graph visualization in general remains a challenging and ongoing area of research.
\end{warn}
\end{problem}

% Problem 7: individual and average Bacon numbers
\begin{problem}
Implement the \li{bacon_number} method in the \li{BaconSolver} class.
Accept start and target values and return the number of actors in the shortest path from start to target.
Note that this is different than the number of entries in the shortest path list, since movies do not contribute to an actor's Bacon number.

Also implement the \li{average_bacon} method.
Compute the average Bacon number across all of the actors in the stored collection of actors.
Exclude any actors that are not connected to Kevin Bacon (their theoretical Bacon number would be infinity).
Return the average Bacon number and the number of actors not connected at all to Kevin Bacon.
\end{problem}

As an aside, the prolific \href{https://en.wikipedia.org/wiki/Paul_Erd%C5%91s}{Paul Erd{\"o}s} is \href{https://xkcd.com/599/}{the Kevin Bacon of mathematicians}.
Someone with an Erd{\"o}s number of $2$ co-authored a paper with someone who co-authored a paper with Paul Erd{\"o}s.

% Problem 8 (Optional)
\begin{problem}
(Optional) Create a \li{plot_bacon} method in the \li{BaconSolver} class that produces a simple histogram displaying the frequency of the Bacon numbers in the data set.
The output should look something like Figure \ref{fig:bacon_numbers}.
\begin{figure}[H]
\includegraphics[width=\textwidth]{baconDistribution.png}
\caption{The frequency of the bacon numbers.}
\label{fig:bacon_numbers}
\end{figure}
\end{problem}

% ============================== END OF LAB ============================== %




% Old material
\begin{comment}
\section*{Graphs}
\label{Graphs_section}
We commonly use graphs to represent the relationships between objects in a set. A graph is
represented by a set of nodes (objects) and a set of edges (relationships) where each edge
connects exactly two nodes. We would indicate an edge from node $x$ to node $y$ by $(x, y)$
and an edge from $y$ to $x$ by $(y, x)$. If \emph{all} of the edges within a graph are bidirectional
between their connecting nodes, the graph is said to be \emph{undirected}. If, however, the directions
of a graph's edges are specified, then the graph is said to be \emph{directed}. In this lab we will largely work
with undirected graphs.

There are two different data structures that can be used to represent graphs: adjacency matrices and adjacency lists.
Each data structure has its own advantages and disadvantages; the structure we use depends on the type of problem we are solving.

\begin{figure}
\centering
\begin{tikzpicture}[auto,node distance=1.5cm,
 thick,main node/.style={circle,draw}]

  \node[main node] (1) {A};
  \node[main node] (2) [left of=1] {B};
  \node[main node] (3) [above of=1] {C};
  \node[main node] (4) [right of=1] {D};
  \node[main node] (5) [below of=1] {E};

  \path[every node/.style={font=\sffamily\small}]
     (1) edge node [] {} (4)
     	  edge node [] {} (3)
     	  edge node [] {} (5)
     (2) edge node [] {} (1)
     	  edge node []{}(3)
     (3) edge node []{}(4);
\end{tikzpicture}
\caption{Example Graph 1}
\label{Adjacency}
\end{figure}


\subsection*{Adjacency Matrices}
An adjacency matrix is two dimensional matrix that is used to represent a graph. To construct an adjacency matrix, we order
the nodes of the graph and allow each node to correspond to one column and one
row of the matrix. Therefore, if we have $n$ nodes, we use an $n \times n$ matrix to
represent the edges between the nodes. In an unweighted graph (a graph where all the edges have the same value), we indicate an
edge using either a $0$ or a $1$.
Consider Example Graph 1 in Figure \ref{Adjacency}. Because a bidirectional edge exists between A and D, for example, we put a $1$ in the $(3, 0)$ position and
in the $(0, 3)$ position. Since no edge exists between A and C, we put a $0$ in
the $(2, 0)$ position and $(0, 2)$ position. We can represent the adjacency matrix for this graph as follows:

\[
\bordermatrix{\hspace{.4cm}&A&B&C&D&E\cr
                A&0 & 1 & 0 & 1 & 1\cr
                B& 1 & 0 & 1 & 0 & 0\cr
                C& 0 & 1 & 0 & 1 & 0\cr
                D& 1 & 0 & 1 & 0 & 0\cr
                E& 1 & 0 & 0 & 0 & 0}\]
Note that because this graph is undirected, its adjacency matrix is symmetric.

\subsection*{Adjacency Lists}
An adjacency list links each node of the graph to a list of its corresponding neighbors, the nodes to which it is connected by an edge.
There are many ways to index the nodes so we can easily access their adjacent neighbors, but, in Python, one of the most straightforward ways is to use a simple dictionary.
We could represent Graph 1 using the following code:
\begin{lstlisting}
AList = {'A': ['B', 'D', 'E'], 'B': ['A', 'C'], 'C': ['B', 'D'], 'D': ['A', 'C'], 'E': ['A']}
# To obtain a list of the nodes adjacent to A, simply access the
# dictionary at the key 'A'.
print Alist['A']
# You should obtain the following output:
['B', 'D', 'E']
\end{lstlisting}
We can retrieve the neighbors of any node of the graph in constant time.
This makes algorithms that operate locally on the graph highly efficient.

\section*{Searching Graphs}
There are two common ways to search a graph, both of which present different advantages depending on the purpose of the search.
One method is called a depth-first search (DFS).  It is designed to search the deepest levels of a graph first.
The other method is called a breadth-first search (BFS).  A BFS searches a graph one level at a time until it finds a solution.

\begin{figure}
\centering
\begin{tikzpicture}[auto,node distance=1.5cm,
 thick,main node/.style={circle,draw}]
\centering
  \node[main node](1) at (-1.25,1.25) {A};
  \node[main node](2) at (.75,1.5)  {B};
  \node[main node](3) at (0,0) {C};
  \node[main node](4) at (-1.6,-.75) {D};
  \node[main node](5) at (1.5,0)  {E};
  \node[main node](6) at (-.2,-1.5)  {F};

  \path[every node/.style={font=\sffamily\small}]
  	(2) edge node[]{}(1)
  	(4) edge node[]{}(1)
  	     edge node[]{}(3)
  	     edge node[]{}(6)
	(6) edge node[]{}(3)
	     edge node[]{}(5);
\end{tikzpicture}
\caption{Example Graph 2}
\label{bfs_dfs}
\end{figure}

Using Graph 2 in Figure \ref{bfs_dfs}, we will walk through two examples of a depth-first search.
In these examples, when a node has multiple branches originating from it,
we will visit the latest (greater) letter in the alphabet first.
The node at which the algorithm begins is called the ``root node''.
First, we will use D as our root node and E as our target node.
Starting with D, we look at D's greatest neighbor, F, then at F's greatest
neighbor, E. Since E is our target, the algorithm ends.

Second, we start with A and search for B.
We visit node A, then D, then F, and finally E.
At this point, we have gone to the deepest level possible without finding our target, B.
We must back up and try another branch of nodes;
the algorithm backtracks from E to F to try another route.
Here, it is very important that we mark those nodes we have already visited,
otherwise the algorithm would infinitely loop around the latter portion of
the graph without reaching our target, B. Since we have marked D as previously visited, we visit F's final neighbor, C.
We return to node F. Since we have already
searched all possible nodes adjacent to F, we backtrack, again, to D. Because we have
exhausted all sub-branches originating from D, we travel back to A and try
any unexplored branches there. Finally, we find B and the algorithm ends.

Let's try the same two searches using a breadth-first search. While exploring our branches this time, however,
we will visit the earliest (lesser) letter in the alphabet first. In this first search, we again use D as our root node and
E as our target node.
We start by searching for E among the neighbors of D: A, C, and F.
We have not found E, so we search among the neighbors of these adjacent nodes, starting with A.
B is the only neighbor of A that we have not already visited; we backtrack to our previous collection of neighbors: A, C, and F.
We have already visited both neighbors of C (namely D and F), so we move on to the adjacent nodes of F. Finally, we find E among the neighbors of F, and the algorithm ends.

In the second search, we start with A.
Since B is among the neighbors of A, we find it immediately.

Both DFS and BFS have advantages.
If we are able to choose a root node that is somewhat local to the target node, BFS is obviously the better choice. However,
DFS can be much more efficient when the solution is far from the target node.
Algorithm \ref{alg:BFSDFS} outlines the process by which we may implement the methods for a BFS and DFS, respectively.

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{BFS/DFS}{$G, root, destination$}
	\State $Q \gets \text{Deque (BFS) or list (DFS) with root node in it}$	\Comment{Initialization steps.}
	\State $marked \gets \text{Set with root node in it}$	
	\State $visited \gets \text{empty list}$	
	\While{$Q \text{ has elements}$}						\Comment{Go through the graph.}
		\State $t \gets Q\text{'s left (BFS) or right (DFS) element}$	
		\State $\text{add }t \text{ to the visited list}$
		\If{$t==destination$}							\Comment{Find the destination node.}
			\State \pseudoli{return} $t,visited$
		
		\Else										\Comment{Visit $t$'s neighbors.}
			\For{$k \text{ in the adjacent nodes of } t$}
				\If{$k \text{ not in } marked$}
					\State $\text{add } k \text{ to } marked$
					\State $\text{add } k \text{ to } Q$
				\EndIf
			\EndFor
		\EndIf
	\EndWhile
\EndProcedure
\end{algorithmic}
\caption{Breadth-first and depth-first searches}
\label{alg:BFSDFS}
\end{algorithm}

\begin{problem}
Implement methods that will perform depth-first and breadth-first searches on a graph
(in this case, an adjacency list). Use a \li{set()} to store the visited nodes.
(Because Python implements sets as hash tables, they have very efficient membership
testing.)

\emph{Helpful Hint}: The implementations of a depth and a breadth-first search
are almost exactly same, but they use a particular data structure differently.
Which data structure constitutes this important difference? How is it used differently?
\end{problem}

\section*{Bidirectional Searching an Unweighted Graph}

\begin{figure}
\centering
\begin{tikzpicture}[
  level distance=1.5 cm,
  level 1/.style={sibling distance=5cm},
  level 2/.style={sibling distance=2.5cm},
  level 3/.style={sibling distance=1.25cm}, thick]

  \node[circle,draw] {A}
	child {node[circle,draw]{B}
		child{node[circle,draw]{D}
			child{node[circle,draw]{H}}
			child{node[circle,draw]{I}}
		}
		child{node[circle,draw]{E}
			child{node[circle,draw]{J}}
			child{node[circle,draw]{K}}
		}
	}
	child{node[circle,draw]{C}
		child{node[circle,draw]{F}
			child{node[circle,draw]{L}}
			child{node[circle,draw]{M}}
		}
		child{node[circle,draw]{G}
			child{node[circle,draw]{N}}
			child{node[circle,draw]{O}}
		}
	};
\end{tikzpicture}
\caption{Example Graph 3}
\label{Bidirectional}
\end{figure}

Let A be an unweighted graph. This means that none of the edges of A has any value, or ``weight'' attached to it. How can we find the shortest path between two nodes?
One way would be to simply use a breadth-first search, stopping when we reach the
target node. The downside to this approach is that the algorithm would visit (at least)
every node on every level prior to the target node before it could end. Observe Graph 3 in Figure \ref{Bidirectional} above.
Let us use a simple BFS to search for O, starting with A as our root node.
We begin by searching through all of the neighbors of A, all of the neighbors of B
and C, and so on until we finally locate O. Using this method, we are forced to check
a total of $15$ nodes before our algorithm ends.

A better way to find the shortest path is to use a breadth-first search from
both A \emph{and} O. Thus, we find the shortest path using a pair of breadth-first searches originating from the root node and the target node, respectively.
We advance each BFS one node at a time, alternating until they meet, and then
construct the shortest path of nodes between our root and target.
Using the BFS algorithm from above, we start with A and locate its
least neighbor, B. Since we have not yet found O (or a connection to O) we visit G,
the first neighbor of O. Continuing in this pattern, we return to the neighbors
of A to visit C. Again, we return to our second search to visit the least neighbor of
G, which is also C. We have found our connection, so the algorithm ends. Note that when we used a breadth-first
search with only one root node, we visited $15$ nodes, but when we used a bidirectional BFS, we only had to visit $5$ nodes to find our path.

The speedup from doing a breadth-first search from both sides is especially evident in larger graphs, where each level
contains more nodes as we search away from our root. Indeed, a bidirectional search is one of the best ways to find shortest
paths in unweighted, undirected graphs. For weighted graphs there are many algorithms
that allow us to find the shortest path. For further information research Dijkstra's Algorithm, Johnson's algorithm, the Bellman--Ford algorithm, the Floyd--Warshall algorithm, and A* search algorithm.

\section*{Six Degrees of Kevin Bacon}
\begin{figure}
\includegraphics[scale = .4]{Kevin_Bacon.jpg}
\caption{Kevin Bacon.  Image source: Wikipedia.}
\end{figure}

The theory of ``the 6 Degrees of Separation'' suggests that each person in the world can be linked to any other person by 6 or less steps, or degrees, of acquaintanceship.
Similarly, the game ``the 6 Degrees of Kevin Bacon'' contends that every actor in the film industry can be linked to Kevin Bacon by 6 degrees or less. Kevin Bacon
is a prolific American actor whose film career spans over 30 years in a variety of genres. As such, he once reputably commented that he had either worked with everyone in
Hollywood or someone who has worked with them. The goal of the game, then, is to find the lowest Bacon number for each actor, a process demonstrated as follows:
\begin{enumerate}
\item Kevin Bacon has a Bacon number of $0$.
\item Actors that have been in a movie with Kevin Bacon have a Bacon number of $1$.
\item For all other actors $X$, if $n$ is the lowest Bacon number of any actor that $X$ has been in a film with, $X$ has a Bacon number of $n+1$.
\end{enumerate}

\begin{figure}
\includegraphics[scale = .6]{Example}
\caption{Jeffrey Humphery was in \emph{End Game} with Cuba Gooding Jr., who was in \emph{A Few Good Men} with Kevin Bacon, so Jeffrey Humphrey has a Bacon Number of 2.  Image source: http://oracleofbacon.org/.}
\end{figure}

We can define a graph in the same way: where each actor is a node and there is an edge between any two nodes if their actors were in a movie together. From this structure we can find
the shortest path between any actor and Kevin Bacon by using any of the algorithms listed above. Of course, this game is not limited to Kevin Bacon; we could use any actor as our ``root actor.''
In fact, ``the Six Degrees of Separation'' can be applied to many different fields. Its most famous application is known as the Erdos numbers: how far away is a person
 from publishing a paper (rather than starring in a movie) with the prolific mathematician Paul Erdos?

\section*{NetworkX}
For this lab, we are going to use a network library called NetworkX. NetworkX is a useful Python package that allows us to create and manipulate large, complex networks.
When considering efficiency, however, it is important to note that because NetworkX uses Python objects to represent its graphs internally, graphs with many nodes will
use a large chunk of memory. (Other network libraries, such as igraph, are written in C++ and may therefore significantly reduce the overhead of storing such a graph.)
To make an undirected graph in NetworkX, we simply code the following:

\begin{lstlisting}
import networkx as nx
G = nx.Graph()
\end{lstlisting}

As an example, we will create a NetworkX graph that links the ingredients of
delicious americanized Italian foods together. We first want to add the ingredients as nodes
to our graph. To add nodes we can use either the \li{add_node(x)} method, where $x$
is the node we want to add, or the \li{add_nodes_from()} method, to
add multiple nodes at once.

\begin{lstlisting}
import networkx as nx
G = nx.Graph()

G.add_node('dough')
PizzaIngredients = ['dough', 'mozzarella cheese', 'tomato sauce', 'ham', 'pineapple']
G.add_nodes_from(PizzaIngredients)
\end{lstlisting}
Note that even though we added \li{'dough'} twice, the graph will only store this node once. NetworkX also comes with \li{has_node(x)} and \li{has_edge(x,y)} methods that will tell
us if a node $x$ or an edge $(x,y)$ has already been added.

Now we want to connect our pizza ingredients together. Adding an edge is simple; we just use the \li{add_edge(x,y)} method, where $x$ and $y$ are previously added nodes.
Again, we can also add multiple edges using the \li{add_edges_from()} method.
However, these edges must be provided as 2-tuples \li{(x,y)}, so we use the
itertools module to create a list of the edges we want to add. It might be wise
to review previous labs and the Python documentation for this module as you implement
NetworkX graphs.

\begin{lstlisting}
from itertools import permutations
Pizza = permutations(PizzaIngredients, 2)
G.add_edges_from(Pizza)
\end{lstlisting}
If we add an edge between two non-existent nodes, the missing nodes will also be added to the graph. Let's add the ingredients for lasagna to the graph using only the \li{add_edges_from} method.
\begin{lstlisting}
LasagnaIngredients = ['lasagna noodles', 'sausage', 'mozzarella cheese', 'cottage cheese', 'tomato sauce', 'egg', 'parsley']
Lasagna = permutations(LasagnaIngredients, 2)
G.add_edges_from(Lasagna)
\end{lstlisting}
We can also remove nodes using the methods \li{remove_node(x)} and \li{remove_nodes_from()}.
Let's say, for example, that we are vegetarians and want to remove the
sausage and ham from our graph. Then, we simply run the following code:
\begin{lstlisting}
G.remove_nodes_from(['sausage', 'ham'])
\end{lstlisting}

Sometimes, with smaller graphs, it can be useful to visualize how nodes are linked together. However, the overhead associated with displaying larger graphs makes this unwise for extensive data sets.
For our example, though, it makes it easy to see the connections between our lasagna and pizza ingredients:

\begin{lstlisting}
# MatPlotLib is a standard Python plotting library; it allows you to plot
# and display your 2D graph.
import matplotlib.pyplot as plt
# Allows you to draw a simple diagram of the nodes and their connecting edges.
nx.draw(G)
# Displays your graph.
plt.show()
\end{lstlisting}


\begin{problem}
The data file, \texttt{movieData.txt}, contains the entire casts of movies made over the course of several years. It is a delimited file with each field delimited by the `/' character. Write a method that will implement the following:
\begin{itemize}
\item Open the file.
\item Generate a NetworkX graph, with the actors as nodes and with edges connecting all of the actors within the same movie to one another. Do not include movie titles as nodes.
\item Return your constructed NetworkX graph (note that, because of the large amount of data, you \textbf{should not} attempt to display this graph).
\end{itemize}
\emph{Helpful Hints:}
\begin{itemize}
\item For later solutions, it might be beneficial to also construct a map from the actors to the movies they appeared in.
\item For certain machine types, take care to open your file using universal newline support. See previous labs for further information.
\end{itemize}
\end{problem}

For a graph, G, the \li{shortest_path(G, x, y)} function in NetworkX outputs
the shortest path from $x$ to $y$ as a list. If more than one such path exists,
it will simply return the first of the shortest paths that it finds. In an
unweighted graph, this method finds the shortest path using a bidirectional search,
a process outlined earlier in this chapter. However, if no path exists between nodes
$x$ and $y$ then NetworkX will raise an exception. If we don't specify a
target, then the function will find the shortest paths between our root,
$x$, and every other node in the network.  It will return the results as a dictionary.


We can find the length of the shortest path using the \li{shortest_path_length(G, x, y)}
function. Again, the target node for this function is optional; if we only
specify the graph and the root node, \li{shortest_path_length()} will return a dictionary
with all \emph{connecting} nodes as keys. When we don't provide a target, if no path exists between the root
and another node then NetworkX will simply omit that node from the dictionary (rather than raise an exception).

\begin{problem}
Find the shortest path between Kevin Bacon and Liam Neeson. Then find the shortest path from Kevin Bacon to Imran Zahid. Write a function that will accept two actors and output
the path between them, along with the movies in between that connect each step of the path. Output the paths from Kevin Bacon to Liam Neeson and Imran Zahid along with the connecting movies.
\end{problem}

\begin{problem}
Find the average Bacon number for the dataset. Then find the number of actors
associated with each Bacon number and the number of actors that have no connection
 to Kevin Bacon at all (we would say these people have a Bacon number of infinity).
\end{problem}
\end{comment}

