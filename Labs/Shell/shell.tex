\lab{Unix Shell}{Shell}
\label{lab:Shell}
% Written by Tanner Christensen, Summer 2015
% If more content in the Problems is needed, in Problem 6, we could add:
%    "edit count_files.py to exclude the files in the test directory"

\objective{Introduce the basics of the Unix Shell commands and integrate Unix Shell commands with Python}

Unix was first developed by AT\&T Bell Labs in the 1970s. In the 1990s, Unix became the foundation of Linux and MacOSX. The majority of servers are written in Linux, so having a knowledge of Unix shell commands allows us to interact with these servers. 

The more you learn about Unix, you will find it is easy to learn but difficult to master. We will build a foundation of simple file system navigation, job control, and basic system remote access. We will address some of the basics in detail and also include lists of commands that are worth learning.

\section*{File System}
\subsection*{Navigation}

Begin by opening the Terminal. The text you see in the upper left of the Terminal window is called the \emph{prompt}. We will begin using three very basic commands: \li{pwd}, \li{ls}, and \li{cd}. The \li{pwd} command stands for print working directory. The \li{ls} command lists the files and subdirectories within the working directory. The \li{cd} command changes the working directory.

%The only reason this problem exists is to make sure it is VERY clear not to mess with the Shell-Lab directory

\begin{problem}
Using these commands, navigate to the \li{Shell-Lab} directory provided with this lab. We will use this directory for the remainder of the lab. Use the \li{ls} command to list the contents of this directory. NOTE: You will find a directory within this directory called \li{test} that is availabe for you to experiment with the concepts and commands found in this lab. The other files and directories are necessary for the exercises we will be doing, so take care not to modify them.
\end{problem}

\subsection*{Flags}
Most commands can be customized using flags. The \li{ls} command has dozens of optional flags. Table \ref{table:ls_flags} contains some of the most common flags for the \li{ls} command.

\begin{table}
\begin{tabular}{l|l} 
Flags & Description
\\ \hline 
\li{-a} & Do not ignore hidden files and folders \\ 
\li{-l} & List files and folders in long format \\ 
\li{-r} & reverse order while sorting \\
\li{-s} & print item name and size \\
\li{-t} & Sort output by last modified \\ 
\li{-R} & Print files and subdirectories recursively \\ 
\li{-S} & Sort by size \\ 
\end{tabular} 
\caption{Common flags of the \li{ls} command.}
\label{table:ls_flags} 
\end{table} 

Multiple flags can be combined as one flag. For example, if we wanted to list all the files in a directory in long format sorted by last time modified, we would use \li{ls -a -l -t} or \li{ls -alt}. To view the reference manual for any command, use \li{man}. For example, to view the reference manual for the \li{ls} command, use \li{man ls}.

\subsection*{Other Useful Commands}
Table \ref{table:other_commands} contains a list commonly-used commands and their uses. Many of these commands will be needed throughout this lab and in any typical session with the Unix shell. After some of the commands are flags listed in square brackets that are worth exploring using \li{man}. We highly recommend experimenting with all these commands to become familiar with them. Remember you may freely experiment with these commands in the \li{test} directory.

\begin{lstlisting}
$ cd test
$ touch data.txt				# create new file data.txt
$ mkdir New						# create new directory New
$ ls							# list items in test directory
New 	data.txt
$ cp data.txt New/				# copy data.txt to New directory
$ cd New/						# enter the New directory
$ ls							# list items in New directory
data.txt
$ mv data.txt new_data.txt		# rename data.txt new_data.txt
$ ls							# list items in New directory
 new_data.txt
$ cd ..							# Return to test directory
$ rm -rv New/					# Remove New directory and its contents
 removed 'New/data.txt'
 removed directory: 'New/'
$ clear							# Clear terminal screen
\end{lstlisting}

\begin{table}
\begin{tabular}{l|l} 
Commands & Description
\\ \hline 
\li{clear} & Clear the terminal screen \\
\li{cp file1 dir1} & Create a copy of \li{file1} in \li{dir1} \\
\li{cp file1 file2} & Create a copy of file1 and name it file2 \\
\li{df dir1} & Display available disk space in file system containing \li{dir1} \\
\li{du dir1} & Display disk usage within \li{dir1} [\li{-a}, \li{-h}] \\
\li{mkdir dir1} & Create a new directory named \li{dir1} \\
\li{mkdir -p path/to/new/dir1} & Create \li{dir1} and all intermediate directories \\
\li{mv file1 dir1} & Move \li{file1} to \li{dir1} \\
\li{mv file1 file2} & Rename \li{file1} as \li{file2} \\
\li{rm file1} & Delete \li{file1} [\li{-i}, \li{-v}] \\
\li{rm -r dir1} & Delete \li{dir1} and all items within \li{dir1} [\li{-i}, \li{-v}] \\
\li{touch file1} & Create an empty file named \li{file1} \\
\li{.} & Current directory \\
\li{..} & Parent directory \\
\li{\~} & Home directory \\
\li{/} & Root directory \\
\end{tabular} 
\caption{Other useful commands dealing with the file system.}
\label{table:other_commands} 
\end{table} 

\begin{problem}
Inside the \li{Shell-Lab} directory, delete the \li{Audio} folder along with all its contents. Create \li{Documents}, \li{Photos}, and \li{Python} directories.
\end{problem}

\subsection*{Wildcards}
As we are working in the file system, there will be times that we want to perform  the same command to a group of similar files. For example, if you needed to move   all text files within a directory to a new directory, the naive way to do this would be to move each text file individually. However, this same result can be achieved using \emph{wildcards}. We use wildcards as placeholder text.  The two wildcards we use most are \li{*} and \li{?}. The \li{*} wildcard represents any string and the \li{?} wildcard represents any character. Though these wildcards can be used in almost every Unix command, they are particularly useful when dealing with files. See Table \ref{table:wildcards}

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{*.txt} & All files that end with \li{.txt}. \\
\li{image*} & All files that have \li{"image"} as the first 5 characters. \\
\li{*py*} & All files that contain \li{"py"} in the name. \\
\li{doc*.txt} & All files of the form \li{doc1.txt}, \li{doc2.txt}, \li{docA.txt}, etc. \\
\end{tabular} 
\caption{Common uses for wildcards.}
\label{table:wildcards} 
\end{table} 

\begin{problem}
Within the \li{Shell-Lab} directory, there are many files. We will organize these files into directories. Using wildcards, move all the \li{.jpg} files to the \li{Photos} directory, all the \li{.txt} files to the \li{Documents} directory, and all the \li{.py} to the \li{Python} directory. You will see a few other folders in the \li{Shell-Lab} directory. Do not move any of the files within these folders at this point.
\end{problem}

\section*{Searching the File System}
There are two powerful commands we use for searching through our directories. The \li{find} command is used to find files or directories in a directory hierarchy. The \li{grep} command is used to find lines matching a string. More specifically, we can use \li{grep} to find words inside files. We will provide a basic template in Table \ref{table:find} for using these two commands and leave it to you to explore the uses of the other flags.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{find dir1 -type f -name "word"} &  Find all files within \li{dir1} with the name \li{"word"} \\ 
 & (\li{-type f} is for files \li{-type d} is for directories)\\
\li{grep -nr "word" dir1} & Find all occurances of \li{"word"} within the files inside \li{dir1} \\ 
 & (\li{-n} lists the line number and \li{-r} performs a recursive search)\\
\end{tabular} 
\caption{Commands using \li{find} and \li{grep}.}
\label{table:find} 
\end{table} 

\begin{problem}
In addition to the .jpg files you have already moved into the \li{Photots} folder, there are a few other .jpg files in a few other folders within the \li{Shell-Lab} directory. Find where these files are using the \li{find} command and move them to the \li{Photos} folder.
\end{problem}

\subsection*{Pipes and Redirects}
Unix becomes even more versatile and powerful when you chain multiple commands together. This is accomplished using \emph{pipes}. Rather than printing the output of a command, the output is passed, or \emph{piped}, to the next command. Two commands are piped together using the \li{|} operator. To demonstrate the power of pipes, we will first introduce a few commands that allow us to view the contents of a file in Table \ref{table:print}

In the first example below, the \li{cat} command output is piped to \li{wc -l}. The \li{wc} command stands for word count. The \li{-l} flag tells the \li{wc} command to count lines. Therefore, this first example counts the number of lines in \li{assignments.txt}. 
In the second example below, the command lists the files in the current directory sorted by size in descending order. For details on what the flags in this command do, consult \li{man sort}.

\begin{lstlisting}
$ cd Shell-Lab/Files/Feb
$ cat assignments.txt | wc -l
9

$ ls -s | sort -nr
12 project3.py
12 project2.py
12 assignments.txt
 4 pics
total 40
\end{lstlisting}
%$

In the previous example, we pipe the contents of \li{assignments.txt} to \li{wc -l} using \li{cat}. When working with files specifically, it is better to use \emph{redirects}. The same output from the first example above can be achieved by running the following command:

\begin{lstlisting}
$ wc -l < assignments.rxt
9
\end{lstlisting}
%$

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{cat} & Print the contents of a file in its entirety \\ 
\li{less} & Print the contents of a file piece by piece \\
\li{head} & Print just the first few lines of a file \\
\li{tail} & Print just the last few lines of a file \\
\end{tabular} 
\caption{Commands for printing contents of a file}
\label{table:print} 
\end{table} 

If you are wanting to save the resulting output of a command to a file, use \li{>} or \li{>>}. The \li{>} operator will overwrite anything that may exist in the output file whereas \li{>>} will append the output to the end of the output file. For example, if we want to append the number of lines in \li{assignments.txt} to \li{word_count.txt}, we would run the following commmand:

\begin{lstlisting}
$ wc -l < assignements.txt >> word_count.txt
\end{lstlisting}
%$

Since \li{grep} is used to print lines matching a pattern, it is also very useful to use in conjunction with piping. For example, \li{ls -l | grep root} prints all files associated with the root user.

\begin{problem}
The \li{words.txt} file in the \li{Documents} directory contains a list of words that are not in alphabetical order. Write the number of words in \li{words.txt} and an alphabetically sorted list of words to \li{sortedwords.txt} using pipes and redirects. Save this file in the \li{Documents} directory. Try to accomplish this with a total of two commands or fewer.
\end{problem}

\section*{File Security}
To begin, run the following command while inside the \li{Shell-Lab} directory:

\begin{lstlisting}
$ cd Shell-Lab/Python
$ ls -l 
-rw-rw-r-- 1 username groupname 194 Aug  5 20:20 calc.py
-rw-rw-r-- 1 username groupname 373 Aug  5 21:16 count_files.py
-rwxr-xr-x 1 username groupname  27 Aug  5 20:22 mult.py
-rw-rw-r-- 1 username groupname 721 Aug  5 20:23 project.py

\end{lstlisting}

Notice the first column of the output. The first character denotes the type of the item whether it be a normal file, a directory, a symbolic link, etc. The remaining nine characters denote the permissions associated with that file. Specifically, these permissions deal with reading, wrtiting, and executing files. There are three categories of people associated with permissions. These are the user (the owner), group, and others. For example, look at the output for \li{mult.py}. The first character \li{-} denotes that \li{mult.py} is a normal file. The next three characters, \li{rwx} tell us the owner can read, write, and execute the file. The next three characters \li{r-x} tell us members of the same group can read and execute the file. The final three characters \li{--x} tell us other users can execute the file and nothing more.

Permissions can be modified using the \li{chmod} command. There are two different  ways to specify permissions, \emph{symbolic permissions} notation and \emph{octal permissions} notation. Symbolic permissions notation is easier to use when we want to make small modifications to a file's permissions.  See Table \ref{table:symbolic}.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{chmod u+x file1} & Add executing permissions to user (owner) \\
\li{chmod g-w file1} & Remove writing permissions from group \\
\li{chmod o-r file1} & Remove reading permissions from other other users \\
\li{chmod a+w file1} & Add writing permissions to everyone \\
\end{tabular} 
\caption{Symbolic permissions notation}
\label{table:symbolic} 
\end{table} 

Octal permissions notation is easier to use when we want to set all the permissions as once. The number 4 corresponds to reading, 2 corresponds to writing, and 1 corresponds to executing. See Table \ref{table:octal}.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{chmod 760 file1} & Sets \li{rwx} to user, \li{rw-} to group, and \li{---} to others \\
\li{chmod 640 file1} & Sets \li{rw-} to user, \li{r--} to group, and \li{---} to others \\
\li{chmod 775 file1} & Sets \li{rwx} to user, \li{rwx} to group, and \li{r-x} to others \\
\li{chmod 500 file1} & Sets \li{r-x} to user, \li{---} to group, and \li{---} to others \\
\end{tabular} 
\caption{Octal permissions notation}
\label{table:octal} 
\end{table} 

The commands in Table \ref{table:chown} are also helpful when working with permissions.

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{chown} & change owner \\
\li{chgrp} & change group \\
\li{getfacl} & view all permissions of a file in a readable format. \\
\end{tabular} 
\caption{Other commands when working with permissions}
\label{table:chown} 
\end{table} 

\section*{Scripts}

A shell script is a series of shell commands saved in a file. Scripts are useful when we have a process that we do over and over again. The following is a very simple script:

\begin{lstlisting}
#!/bin/bash
echo "Hello World"
\end{lstlisting}

Save this script as \li{hello}. Note that no file type is necessary. The first line starts with \li{"#\!"}. This is called the \emph{shebang} or \emph{hashbang} character sequence. It is followed by the absolute path to the \li{bash} interpreter. If we  were unsure where the \li{bash} interpreter is saved, we run \li{which bash}.  To execute a script, type the script name preceded by \li{./}

\begin{lstlisting}
$ ./hello
bash: ./hello: Permission denied

# Notice that you do not have permission to execute this file. This is by default
$ ls -l hello
-rw-rw-r-- 1 username groupname 31 Jul 30 14:34 hello

$ chmod u+x hello
$ ./hello   
Hello World
\end{lstlisting}

You can do this same thing with Python scripts. All you have to do is change the path following the shebang. To see where the Python interpreter is stored, run \li{which python}.

\begin{problem}
In the \li{Python} directory you will find \li{count_files.py}. \li{count_files.py} is a python script that counts all the files within the \li{Shell-Lab} directory. Modify this file so it can be run as a script and change the permissions of this script so the user and group can execute the script.
\end{problem}

If you would like to learn how to run scripts on a set schedule, consider researching \emph{cron jobs}.

\section*{Job Control}
Let's say we had a series of scripts we wanted to run. If we knew that these would take a while to execute, we may want to start them all at the same time and let them run while we are working on something else. In the Table \ref{table:jobs}, we have listed some of the most common commands used in job control. We strongly encourage you to experiment with these commands. In the \li{Scripts} directory, you will find a \li{five_secs} and a \li{ten_secs} script that takes five seconds and ten seconds to execute respectively. These will be particularly useful as you are experimenting with these commands. 

\begin{lstlisting}
$ ./ ten_secs &
$ ./ five_secs &
$ jobs
[1]+  Running		./ten_secs &
[2]-  Running		./five_secs &
$ kill %2
[2]-  Terminated	./five_secs &
$ jobs
[1]+  Running		./ten_secs &
\end{lstlisting}
%$

\begin{table}
\begin{tabular}{l|l} 
Command & Description
\\ \hline 
\li{COMMAND \&} & Adding an ampersand to the end of a command \\
& runs the command in the background \\
\li{bg \%n} & Restarts an interrupted job in the background \\
\li{fg \%n} & Brings the nth job into the foreground \\
\li{jobs} & Lists all the jobs currently running \\
\li{kill \%n} & Terminates the nth job \\
\li{ps} & Lists all the current processes \\
\li{Ctrl-C} & Terminates current job \\
\li{Ctrl-Z} & Interrupts current job \\
\end{tabular} 
\caption{Job control commands}
\label{table:jobs} 
\end{table} 

\begin{problem}
In addition to the \li{five_secs} and \li{ten-secs} scripts, the \li{Scripts} folder contains three scripts that will each take about a forty-five seconds to execute. 
Execute each of these commands in the background so all three are running at the same time. To verify all scripts are running at the same time, write the output of \li{jobs} to a new file \li{log.txt} saved in the \li{Scripts} directory.
\end{problem}

\section*{Python Integration}
To this point, we have barely scratched the surface of all the functionality that Unix has to offer. However, the tools and commands we have addressed so far provide us with a foundation of the basics. 
Using the \li{subprocess} module in Python, we can call Unix commands. By combining Python and the Unix commands, our toolset is automatically broadened.

There are two functions in particular within the \li{subprocess} module we will use. When wanting to run a Unix command, use \li{subprocess.call()}. 
When wanting to run a Unix command and be able to store and manipulate the output, use \li{subprocess.check_output()}. 
These functions have a keyword argument \li{shell} that defaults to \li{False}. We want to set this argument to \li{True} to run the command in the Unix shell.

\begin{lstlisting}
$ cd Shell-Lab/Documents
$ python
>>> import subprocess
>>> subprocess.call("ls -l", shell=True)
-rw-rw-r-- 1 username groupname  142 Aug  5 20:20 assignments.txt
-rw-rw-r-- 1 username groupname  427 Aug  5 20:21 doc1.txt
-rw-rw-r-- 1 username groupname  326 Aug  5 20:21 doc2.txt
-rw-rw-r-- 1 username groupname  612 Aug  5 20:21 doc3.txt
-rw-rw-r-- 1 username groupname  298 Aug  5 20:21 doc4.txt
-rw-rw-r-- 1 username groupname 1027 Aug  5 20:23 review.txt
-rw-rw-r-- 1 username groupname  920 Aug  5 23:50 words.txt
>>> files = subprocess.check_output("ls -l", shell=True)
>>> files
'-rw-rw-r-- 1 tanner tanner  142 Aug  5 20:20 assignments.txt\n-rw-rw-r-- 1 tanner tanner  427 Aug  5 20:21 doc1.txt\n-rw-rw-r-- 1 tanner tanner  326 Aug  5 20:21 doc2.txt\n-rw-rw-r-- 1 tanner tanner  612 Aug  5 20:21 doc3.txt\n-rw-rw-r-- 1 tanner tanner  298 Aug  5 20:21 doc4.txt\n-rw-rw-r-- 1 tanner tanner 1027 Aug  5 20:23 review.txt\n-rw-rw-r-- 1 tanner tanner  920 Aug  5 23:50 words.txt\n'
>>> files.split('\n')
['-rw-rw-r-- 1 tanner tanner  142 Aug  5 20:20 assignments.txt',
 '-rw-rw-r-- 1 tanner tanner  427 Aug  5 20:21 doc1.txt',
 '-rw-rw-r-- 1 tanner tanner  326 Aug  5 20:21 doc2.txt',
 '-rw-rw-r-- 1 tanner tanner  612 Aug  5 20:21 doc3.txt',
 '-rw-rw-r-- 1 tanner tanner  298 Aug  5 20:21 doc4.txt',
 '-rw-rw-r-- 1 tanner tanner 1027 Aug  5 20:23 review.txt',
 '-rw-rw-r-- 1 tanner tanner  920 Aug  5 23:50 words.txt',
 '']
# To get rid of the last empty string in the list
>>> files.pop()
''

# Now that we have a list object, we can manipulate and analyze this data in Python. We can make it even more accessible by splitting the lines again
>>> files = [line.split() for line in files]
\end{lstlisting}

\begin{problem}
Create a \li{Shell} class in Python. Write a \li{find_file} method that will search for a filename starting in the current directory using the \li{find} command. Write a \li{find_word} method that finds a given word within the contents of the current directory using the \li{grep} command. For both these functions, return a list of filepaths.
\end{problem}

\begin{problem}
Write a method for the \li{Shell} class that recursively finds the \li{n} largest files within a directory. Have a keyword argument for the directory that defaults to the current directory. Be sure that your function only returns files. Hint: To view the size of a file \li{file1}, you can use \li{ls -s file1} or \li{du file1}
\end{problem}

\section*{Secure Shell}

Let's say you are working for a company with a file server. Hundreds of people need to be able to access the content of this machine, but how is that possible? Or say you have a script to run that requires some serious computing power. How are you going to be able to access your company's super computer to run your script? We do this through \emph{Secure Shell} (SSH).

SSH is a network protocol encrypted using public-key cryptography. The system we are connecting \emph{to} is commonly referred to as the \emph{host} and the system we are connecting \emph{from} is commonly referred to as the \emph{client}. Once this connection is established, there is a secure tunnel through which commands and files can be exchanged between the client and host.

CODEBOX
logging into a remote computer using ssh

\subsection*{Secure Copy}

When we want to copy files between the client and the host, we use the  \emph{secure copy} command, \li{scp}.

CODEBOX
copy a file from client to host
copy a file from host to client

\begin{problem}
TODO: Finish problem
OPTIONAL
Get with a partner and mess around with SSH. Using scp, copy files back and forth to each other.
\end{problem}

\subsection*{Generating SSH Keys (Optional)}
If there is a host that we access on a regular basis, typing in our password over and over again can get tedious. By setting up SSH keys, the host can identify if a client is a trusted user without needing to type in a password. If you are interested in experimenting with this setup, a Google search of "How to set up SSH keys" will lead you to many quality tutorials on how to do so.
